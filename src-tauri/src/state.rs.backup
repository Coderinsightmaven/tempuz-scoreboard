// src-tauri/src/state.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Mutex;
use tauri::State;

// ==================== APP STATE ====================

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum Theme {
    Light,
    Dark,
    System,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MonitorInfo {
    pub id: u32,
    pub name: String,
    pub width: u32,
    pub height: u32,
    pub x: i32,
    pub y: i32,
    pub is_primary: bool,
    pub scale_factor: f64,
    pub work_area_width: u32,
    pub work_area_height: u32,
    pub work_area_x: i32,
    pub work_area_y: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ScoreboardInstance {
    pub id: String,
    pub window_id: String,
    pub name: String,
    pub monitor_id: u32,
    pub position: Position,
    pub size: Size,
    pub is_active: bool,
    pub created_at: String,
    pub scoreboard_data: Option<serde_json::Value>,
    pub tennis_api_scoreboard_id: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Position {
    pub x: i32,
    pub y: i32,
    pub offset_x: i32,
    pub offset_y: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Size {
    pub width: u32,
    pub height: u32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AppSettings {
    pub auto_save: bool,
    pub auto_save_interval: u64,
    pub recent_files: Vec<String>,
    pub default_canvas_size: Size,
    pub default_grid_size: u32,
    pub show_welcome_screen: bool,
    pub enable_hotkeys: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AppState {
    pub theme: Theme,
    pub sidebar_open: bool,
    pub property_panel_open: bool,
    pub toolbar_compact: bool,
    pub monitors: Vec<MonitorInfo>,
    pub selected_monitor: Option<MonitorInfo>,
    pub scoreboard_instances: Vec<ScoreboardInstance>,
    pub is_loading_monitors: bool,
    pub is_creating_scoreboard_window: bool,
    pub last_error: Option<String>,
    pub settings: AppSettings,
}

impl Default for AppState {
    fn default() -> Self {
        Self {
            theme: Theme::System,
            sidebar_open: true,
            property_panel_open: true,
            toolbar_compact: false,
            monitors: Vec::new(),
            selected_monitor: None,
            scoreboard_instances: Vec::new(),
            is_loading_monitors: false,
            is_creating_scoreboard_window: false,
            last_error: None,
            settings: AppSettings {
                auto_save: true,
                auto_save_interval: 300000, // 5 minutes
                recent_files: Vec::new(),
                default_canvas_size: Size {
                    width: 800,
                    height: 600,
                },
                default_grid_size: 20,
                show_welcome_screen: true,
                enable_hotkeys: true,
            },
        }
    }
}

// ==================== CANVAS STATE ====================

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum ResizeHandle {
    TopLeft,
    Top,
    TopRight,
    Right,
    BottomRight,
    Bottom,
    BottomLeft,
    Left,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AlignmentGuide {
    pub id: String,
    pub orientation: String, // "horizontal" or "vertical"
    pub position: f64,
    pub strength: f64,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanvasGrid {
    pub enabled: bool,
    pub size: u32,
    pub snap_to_grid: bool,
    pub show_grid: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct CanvasState {
    pub canvas_size: Size,
    pub zoom: f64,
    pub pan: Position2D,
    pub grid: CanvasGrid,
    pub selected_components: Vec<String>,
    pub hovered_component: Option<String>,
    pub is_dragging: bool,
    pub drag_offset: Position2D,
    pub is_resizing: bool,
    pub resize_handle: Option<ResizeHandle>,
    pub resized_component_id: Option<String>,
    pub viewport_bounds: Option<DOMRect>,
    pub alignment_guides: Vec<AlignmentGuide>,
    pub clipboard: Vec<serde_json::Value>, // ScoreboardComponent serialized
    pub alignment_snapping: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Position2D {
    pub x: f64,
    pub y: f64,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DOMRect {
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
}

// ==================== IMAGE STATE ====================

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct StoredImage {
    pub id: String,
    pub name: String,
    pub original_name: String,
    pub path: String,
    pub size: u64,
    pub image_type: String,
    pub uploaded_at: String,
    pub thumbnail: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ImageState {
    pub images: Vec<StoredImage>,
    pub is_loading: bool,
    pub last_error: Option<String>,
}

// ==================== VIDEO STATE ====================

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct StoredVideo {
    pub id: String,
    pub name: String,
    pub original_name: String,
    pub path: String,
    pub size: u64,
    pub video_type: String,
    pub duration: Option<f64>,
    pub uploaded_at: String,
    pub thumbnail: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct VideoState {
    pub videos: Vec<StoredVideo>,
    pub is_loading: bool,
    pub last_error: Option<String>,
}

// ==================== LIVE DATA STATE ====================

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct LiveDataConnection {
    pub id: String,
    pub name: String,
    pub provider: String, // "mock", "websocket", etc.
    pub api_url: Option<String>,
    pub poll_interval: u64,
    pub is_active: bool,
    pub created_at: Option<String>,
    pub updated_at: Option<String>,
    pub last_updated: Option<String>,
    pub last_error: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct LiveDataComponentBinding {
    pub component_id: String,
    pub connection_id: String,
    pub data_path: String,
    pub update_interval: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct TennisLiveData {
    pub match_id: String,
    pub player1: PlayerInfo,
    pub player2: PlayerInfo,
    pub score: MatchScore,
    pub sets: HashMap<String, SetScore>,
    pub serve: ServeInfo,
    pub match_status: String,
    pub serving_player: u32,
    pub current_set: u32,
    pub is_tiebreak: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct PlayerInfo {
    pub name: String,
    pub country: String,
    pub seed: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MatchScore {
    pub player1_sets: u32,
    pub player2_sets: u32,
    pub player1_games: u32,
    pub player2_games: u32,
    pub player1_points: String,
    pub player2_points: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SetScore {
    pub player1: u32,
    pub player2: u32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ServeInfo {
    pub speed: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ScoreboardInfo {
    pub id: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct LiveDataState {
    pub connections: Vec<LiveDataConnection>,
    pub active_data: HashMap<String, TennisLiveData>,
    pub component_bindings: Vec<LiveDataComponentBinding>,
    pub is_polling: bool,
    pub polling_intervals: HashMap<String, u64>,
    pub is_loaded: bool,
    pub last_error: Option<String>,
    pub tennis_api_connected: bool,
    pub tennis_api_scoreboards: Vec<ScoreboardInfo>,
}

// ==================== SCOREBOARD STATE ====================

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum ComponentType {
    Background,
    Logo,
    Text,
    TennisPlayerName,
    TennisGameScore,
    TennisSetScore,
    TennisMatchScore,
    TennisDetailedSetScore,
    TennisDoublesPlayerName,
    TennisServingIndicator,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum SportType {
    Generic,
    Tennis,
    Basketball,
    Soccer,
    Football,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ScoreboardComponent {
    pub id: String,
    pub component_type: ComponentType,
    pub position: Position2D,
    pub size: Size,
    pub rotation: f64,
    pub style: ComponentStyle,
    pub data: ComponentData,
    pub locked: bool,
    pub visible: bool,
    pub z_index: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ComponentStyle {
    pub background_color: Option<String>,
    pub border_color: String,
    pub border_width: u32,
    pub border_radius: u32,
    pub opacity: f64,
    pub font_size: u32,
    pub font_family: String,
    pub font_weight: String,
    pub text_color: String,
    pub text_align: String,
    pub vertical_align: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ComponentData {
    pub image_id: Option<String>,
    pub image_url: Option<String>,
    pub text: String,
    pub player_number: Option<u32>,
    pub set_number: Option<u32>,
    pub live_data_binding: Option<LiveDataComponentBinding>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct GameState {
    pub home_score: u32,
    pub away_score: u32,
    pub period: u32,
    pub time_remaining: String,
    pub is_game_active: bool,
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ScoreboardConfig {
    pub id: String,
    pub name: String,
    pub dimensions: Size,
    pub background: BackgroundConfig,
    pub components: Vec<ScoreboardComponent>,
    pub grid_settings: GridSettings,
    pub sport: SportType,
    pub version: String,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BackgroundConfig {
    pub color: String,
    pub image: Option<String>,
    pub opacity: f64,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct GridSettings {
    pub enabled: bool,
    pub size: u32,
    pub snap_to_grid: bool,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ScoreboardState {
    pub config: Option<ScoreboardConfig>,
    pub components: Vec<ScoreboardComponent>,
    pub game_state: Option<GameState>,
    pub selected_template: Option<String>,
    pub is_dirty: bool,
    pub last_saved: Option<String>,
}

// ==================== MANAGED STATE WRAPPERS ====================

pub struct ManagedAppState(pub Mutex<AppState>);
pub struct ManagedCanvasState(pub Mutex<CanvasState>);
pub struct ManagedImageState(pub Mutex<ImageState>);
pub struct ManagedVideoState(pub Mutex<VideoState>);
pub struct ManagedLiveDataState(pub Mutex<LiveDataState>);
pub struct ManagedScoreboardState(pub Mutex<ScoreboardState>);

// ==================== IMPLEMENTATIONS ====================

impl Default for CanvasState {
    fn default() -> Self {
        Self {
            canvas_size: Size {
                width: 800,
                height: 600,
            },
            zoom: 1.0,
            pan: Position2D { x: 0.0, y: 0.0 },
            grid: CanvasGrid {
                enabled: true,
                size: 20,
                snap_to_grid: true,
                show_grid: true,
            },
            selected_components: Vec::new(),
            hovered_component: None,
            is_dragging: false,
            drag_offset: Position2D { x: 0.0, y: 0.0 },
            is_resizing: false,
            resize_handle: None,
            resized_component_id: None,
            viewport_bounds: None,
            alignment_guides: Vec::new(),
            clipboard: Vec::new(),
            alignment_snapping: true,
        }
    }
}

impl Default for ImageState {
    fn default() -> Self {
        Self {
            images: Vec::new(),
            is_loading: false,
            last_error: None,
        }
    }
}

impl Default for VideoState {
    fn default() -> Self {
        Self {
            videos: Vec::new(),
            is_loading: false,
            last_error: None,
        }
    }
}

impl Default for LiveDataState {
    fn default() -> Self {
        Self {
            connections: Vec::new(),
            active_data: HashMap::new(),
            component_bindings: Vec::new(),
            is_polling: false,
            polling_intervals: HashMap::new(),
            is_loaded: false,
            last_error: None,
            tennis_api_connected: false,
            tennis_api_scoreboards: Vec::new(),
        }
    }
}

impl Default for LiveDataState {
    fn default() -> Self {
        Self {
            connections: Vec::new(),
            active_data: HashMap::new(),
            component_bindings: Vec::new(),
            is_polling: false,
            polling_intervals: HashMap::new(),
            is_loaded: false,
            last_error: None,
            tennis_api_connected: false,
            tennis_api_scoreboards: Vec::new(),
        }
    }
}

impl Default for ScoreboardState {
    fn default() -> Self {
        Self {
            config: None,
            components: Vec::new(),
            game_state: None,
            selected_template: None,
            is_dirty: false,
            last_saved: None,
        }
    }
}
