<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Composite Scoreboard Display</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #000; 
            color: #fff; 
            overflow: hidden; 
            height: 100vh; 
            width: 100vw; 
            margin: 0;
            padding: 0;
            position: relative;
        }
        .composite-container { 
            position: absolute; 
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        .scoreboard-area {
            position: absolute;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }
        .scoreboard-container { 
            position: absolute; 
            background: #000;
            width: 100%;
            height: 100%;
            /* Dimensions, scaling and positioning will be set dynamically */
        }
        .image-component {
            position: absolute;
            overflow: hidden;
        }
        .image-component img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .text-component {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            word-wrap: break-word;
            overflow: hidden;
            padding: 4px;
        }
        /* Tennis component styling removed to prevent visual clutter */
        /* Live data indicator removed to prevent visual clutter */
        .loading-message { 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            font-size: 1.2rem; 
            color: #888; 
            text-align: center;
            padding: 20px;
        }
        .debug-info {
            font-size: 0.8rem;
            color: #666;
            margin-top: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .placeholder-text {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            width: 100%; 
            height: 100%; 
            background: #333; 
            color: #fff; 
            font-size: 12px;
            text-align: center;
            padding: 10px;
        }
        /* Area labels removed for cleaner appearance */
        
        /* Score Change Animation Styles */
        .score-change-base {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-increase {
            animation: scoreIncrease 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-decrease {
            animation: scoreDecrease 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-flash {
            animation: scoreFlash 0.6s ease-out;
        }
        
        .score-glow {
            animation: scoreGlow 1s ease-out;
        }
        
        /* Pulse animation removed to prevent visual clutter */
        
        @keyframes scoreIncrease {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes scoreDecrease {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }
        
        @keyframes scoreFlash {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes scoreGlow {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        /* Smooth transitions */
        .text-component, .tennis-component {
            transition: transform 0.2s ease;
        }
        
        /* Ensure animations work well with existing styles */
        .score-change-base, .tennis-component {
            will-change: transform;
        }
    </style>
</head>
<body>
    <div class="composite-container" id="compositeContainer">
        <div class="loading-message" id="loadingMessage">
            <div>Loading Composite Scoreboard...</div>
            <div class="debug-info" id="debugInfo">Initializing...</div>
        </div>
    </div>

    <script>
        let currentWindow = null;
        let compositeLayout = null;
        let debugInfo = document.getElementById('debugInfo');
        let initAttempts = 0;
        const maxInitAttempts = 30; // 30 seconds

        function updateDebug(message) {
            console.log(message);
            if (debugInfo) {
                debugInfo.textContent = message;
            }
        }

        function getWindowId() {
            // Try to extract from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const windowId = urlParams.get('windowId');
            if (windowId) return windowId;
            
            // Try to get from hash
            const hash = window.location.hash;
            if (hash && hash.startsWith('#')) {
                return hash.substring(1);
            }
            
            return null;
        }

        async function initializeCompositeScoreboard() {
            try {
                initAttempts++;
                updateDebug(`Initialization attempt ${initAttempts}/${maxInitAttempts}`);
                
                // First try to use Tauri API if available
                if (window.__TAURI__ && window.__TAURI__.core && window.__TAURI__.webviewWindow) {
                    updateDebug('Using Tauri API...');
                    await initializeWithTauri();
                    return;
                }
                
                // Fallback: Try to get window ID from URL or other sources
                const windowId = getWindowId();
                if (windowId) {
                    updateDebug(`Found window ID: ${windowId}`);
                    renderDefaultComposite(`Window: ${windowId}`);
                    return;
                }
                
                // If we still don't have a way to get data, retry or show default
                if (initAttempts < maxInitAttempts) {
                    updateDebug(`Retrying in 1 second... (${initAttempts}/${maxInitAttempts})`);
                    setTimeout(initializeCompositeScoreboard, 1000);
                } else {
                    updateDebug('Max attempts reached, showing default');
                    renderDefaultComposite();
                }
                
            } catch (error) {
                console.error('Initialization error:', error);
                updateDebug(`Error: ${error?.message || error || 'Unknown error'}`);
                
                if (initAttempts < maxInitAttempts) {
                    setTimeout(initializeCompositeScoreboard, 1000);
                } else {
                    showMessage('Failed to initialize: ' + (error?.message || error || 'Unknown error'));
                }
            }
        }

        async function initializeWithTauri() {
            const { invoke } = window.__TAURI__.core;
            const { getCurrentWebviewWindow } = window.__TAURI__.webviewWindow;
            
            currentWindow = getCurrentWebviewWindow();
            const windowLabel = currentWindow.label;
            
            updateDebug(`Getting composite layout for window: ${windowLabel}`);
            
            try {
                // Get the composite layout data from the scoreboard instance
                const instanceData = await invoke('get_scoreboard_instance_data', { 
                    windowId: windowLabel 
                });
                
                console.log('=== COMPOSITE SCOREBOARD DEBUG ===');
                console.log('Window label:', windowLabel);
                console.log('Raw instance data:', instanceData);
                console.log('Instance data type:', typeof instanceData);
                console.log('Instance data keys:', instanceData ? Object.keys(instanceData) : 'null');
                
                if (instanceData) {
                    console.log('Instance data structure:');
                    console.log('  - isComposite:', instanceData.isComposite);
                    console.log('  - compositeLayout exists:', !!instanceData.compositeLayout);
                    if (instanceData.compositeLayout) {
                        console.log('  - compositeLayout keys:', Object.keys(instanceData.compositeLayout));
                        console.log('  - compositeLayout.areas length:', instanceData.compositeLayout.areas?.length);
                    }
                }
                
                const layoutData = instanceData && instanceData.compositeLayout ? instanceData.compositeLayout : null;
                
                console.log('Extracted layout data:', layoutData);
                console.log('=== END DEBUG ===');
                
                if (layoutData) {
                    compositeLayout = layoutData;
                    updateDebug(`Found ${compositeLayout.areas ? compositeLayout.areas.length : 0} scoreboard areas`);
                    await renderCompositeScoreboard(compositeLayout);
                } else {
                    updateDebug('No layout data found, using default');
                    renderDefaultComposite(`Window: ${windowLabel} | No layout data`);
                }
            } catch (error) {
                console.error('Error in initializeWithTauri:', error);
                updateDebug(`Tauri initialization error: ${error?.message || error || 'Unknown error'}`);
                renderDefaultComposite(`Error: ${error?.message || error || 'Unknown error'}`);
            }
        }

        async function renderCompositeScoreboard(layout) {
            const container = document.getElementById('compositeContainer');
            const loadingMessage = document.getElementById('loadingMessage');
            
            updateDebug('Rendering composite scoreboard...');
            loadingMessage.style.display = 'none';
            
            // Set overall background
            if (layout.background) {
                container.style.backgroundColor = layout.background.color || '#000';
            }
            
            // Calculate scale factors to fit the window
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const scaleX = windowWidth / layout.totalWidth;
            const scaleY = windowHeight / layout.totalHeight;
            
            console.log(`Composite Layout Scaling:
                Layout: ${layout.totalWidth}x${layout.totalHeight}
                Window: ${windowWidth}x${windowHeight}
                Scale X: ${scaleX.toFixed(3)}x
                Scale Y: ${scaleY.toFixed(3)}x`);
            
            // Render each scoreboard area
            for (const area of layout.areas) {
                await renderScoreboardArea(area, scaleX, scaleY);
            }
            
            // Add window resize listener
            window.addEventListener('resize', () => {
                // Recalculate and reposition areas on window resize
                const newWindowWidth = window.innerWidth;
                const newWindowHeight = window.innerHeight;
                const newScaleX = newWindowWidth / layout.totalWidth;
                const newScaleY = newWindowHeight / layout.totalHeight;
                
                updateAreaPositions(newScaleX, newScaleY);
            });
        }

        async function renderScoreboardArea(area, scaleX, scaleY) {
            const container = document.getElementById('compositeContainer');
            
            // Create area container
            const areaElement = document.createElement('div');
            areaElement.className = 'scoreboard-area';
            areaElement.id = `area-${area.id}`;
            
            // Position and size the area
            areaElement.style.left = (area.x * scaleX) + 'px';
            areaElement.style.top = (area.y * scaleY) + 'px';
            areaElement.style.width = (area.width * scaleX) + 'px';
            areaElement.style.height = (area.height * scaleY) + 'px';
            
            // Area labels removed for cleaner appearance
            
            // Create scoreboard container within the area
            const scoreboardContainer = document.createElement('div');
            scoreboardContainer.className = 'scoreboard-container';
            scoreboardContainer.id = `scoreboard-${area.id}`;
            areaElement.appendChild(scoreboardContainer);
            
            container.appendChild(areaElement);
            
            // Load scoreboard data if available
            if (area.scoreboardId) {
                try {
                    updateDebug(`Loading scoreboard data for area: ${area.name}`);
                    console.log(`Attempting to load scoreboard: ${area.scoreboardId} for area: ${area.name}`);
                    
                    if (window.__TAURI__ && window.__TAURI__.core) {
                        const { invoke } = window.__TAURI__.core;
                        
                        // First, let's see what scoreboards are available
                        try {
                            const availableScoreboards = await invoke('list_scoreboards');
                            console.log('Available scoreboards:', availableScoreboards);
                            console.log('Looking for scoreboardId:', area.scoreboardId);
                            
                            // Check if we can find a matching scoreboard
                            const matchingScoreboard = availableScoreboards.find(sb => 
                                sb.id === area.scoreboardId || sb.filename === area.scoreboardId
                            );
                            console.log('Matching scoreboard found:', matchingScoreboard);
                        } catch (listError) {
                            console.warn('Could not list available scoreboards:', listError);
                        }
                        let scoreboardData = null;
                        
                        // Try loading by the scoreboardId first
                        try {
                            scoreboardData = await invoke('load_scoreboard', { 
                                filename: area.scoreboardId 
                            });
                        } catch (firstError) {
                            console.log(`Failed to load by filename '${area.scoreboardId}':`, firstError);
                            
                            // If that fails, try to find by ID in the available scoreboards
                            try {
                                const availableScoreboards = await invoke('list_scoreboards');
                                const matchingScoreboard = availableScoreboards.find(sb => sb.id === area.scoreboardId);
                                
                                if (matchingScoreboard) {
                                    console.log(`Found scoreboard by ID, trying filename: ${matchingScoreboard.filename}`);
                                    scoreboardData = await invoke('load_scoreboard', { 
                                        filename: matchingScoreboard.filename 
                                    });
                                }
                            } catch (secondError) {
                                console.log('Failed to find scoreboard by ID either:', secondError);
                            }
                        }
                        
                        if (scoreboardData) {
                            // Extract the actual scoreboard config data
                            const configData = scoreboardData.data || scoreboardData;
                            await renderScoreboardInArea(scoreboardContainer, configData, area);
                        } else {
                            renderEmptyArea(scoreboardContainer, `Scoreboard not found: ${area.scoreboardId}<br/>Available scoreboards: ${availableScoreboards ? availableScoreboards.map(sb => sb.name).join(', ') : 'none'}`);
                        }
                    } else {
                        renderEmptyArea(scoreboardContainer, 'Tauri API not available');
                    }
                } catch (error) {
                    console.error(`Failed to load scoreboard for area ${area.name}:`, error);
                    console.error('Area config:', area);
                    console.error('Attempted scoreboardId:', area.scoreboardId);
                    renderEmptyArea(scoreboardContainer, `Error: ${error?.message || error || 'Unknown error loading scoreboard'}`);
                }
            } else if (area.scoreboardData) {
                // Use inline scoreboard data
                await renderScoreboardInArea(scoreboardContainer, area.scoreboardData, area);
            } else {
                // Empty area
                renderEmptyArea(scoreboardContainer, `Empty area: ${area.name}`);
            }
        }

        async function renderScoreboardInArea(container, scoreboardData, area) {
            // Store original design dimensions
            let originalDimensions = { width: 800, height: 600 };
            
            if (scoreboardData.config && scoreboardData.config.dimensions) {
                originalDimensions = {
                    width: scoreboardData.config.dimensions.width || 800,
                    height: scoreboardData.config.dimensions.height || 600
                };
            } else if (scoreboardData.dimensions) {
                originalDimensions = {
                    width: scoreboardData.dimensions.width || 800,
                    height: scoreboardData.dimensions.height || 600
                };
            }
            
            // Set background
            if (scoreboardData.background) {
                container.style.backgroundColor = scoreboardData.background.color || '#000';
            }
            
            // Calculate scale to fit the scoreboard within the area
            const areaWidth = area.width;
            const areaHeight = area.height;
            const scaleX = areaWidth / originalDimensions.width;
            const scaleY = areaHeight / originalDimensions.height;
            
            // Use uniform scaling to maintain aspect ratio, or stretch to fill
            const useUniformScale = true; // You can make this configurable
            let finalScaleX, finalScaleY;
            
            if (useUniformScale) {
                const uniformScale = Math.min(scaleX, scaleY);
                finalScaleX = uniformScale;
                finalScaleY = uniformScale;
            } else {
                finalScaleX = scaleX;
                finalScaleY = scaleY;
            }
            
            // Set container dimensions and scaling
            container.style.width = originalDimensions.width + 'px';
            container.style.height = originalDimensions.height + 'px';
            container.style.transform = `scaleX(${finalScaleX}) scaleY(${finalScaleY})`;
            container.style.transformOrigin = 'top left';
            
            // Render components
            if (scoreboardData.components && scoreboardData.components.length > 0) {
                for (const component of scoreboardData.components) {
                    if (component.type === 'background' || component.type === 'logo') {
                        await renderImageComponent(component, container);
                    } else if (component.type === 'video') {
                        await renderVideoComponent(component, container);
                    } else if (component.type === 'text') {
                        renderTextComponent(component, container);
                    } else if (component.type.startsWith('tennis_')) {
                        renderTennisComponent(component, container);
                    }
                }
            } else {
                renderEmptyArea(container, 'No components in design');
            }
            
            console.log(`Rendered scoreboard in area ${area.name}:
                Original: ${originalDimensions.width}x${originalDimensions.height}
                Area: ${areaWidth}x${areaHeight}
                Scale: ${finalScaleX.toFixed(3)}x, ${finalScaleY.toFixed(3)}x`);
        }

        function renderEmptyArea(container, message) {
            container.innerHTML = `<div class="placeholder-text">${message}</div>`;
        }

        function updateAreaPositions(scaleX, scaleY) {
            if (!compositeLayout) return;
            
            for (const area of compositeLayout.areas) {
                const areaElement = document.getElementById(`area-${area.id}`);
                if (areaElement) {
                    areaElement.style.left = (area.x * scaleX) + 'px';
                    areaElement.style.top = (area.y * scaleY) + 'px';
                    areaElement.style.width = (area.width * scaleX) + 'px';
                    areaElement.style.height = (area.height * scaleY) + 'px';
                }
            }
        }

        // Image and text component rendering functions (similar to regular scoreboard)
        async function renderImageComponent(component, container) {
            const element = document.createElement('div');
            element.className = 'image-component';
            element.style.position = 'absolute';
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1;
            
            // Apply styling
            if (component.style) {
                if (component.style.backgroundColor) {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Load image if available
            if (component.data && component.data.imageId) {
                try {
                    if (window.__TAURI__ && window.__TAURI__.core) {
                        const { invoke } = window.__TAURI__.core;
                        const imageData = await invoke('get_image_data', { 
                            imageId: component.data.imageId 
                        });
                        
                        const img = document.createElement('img');
                        img.src = imageData;
                        img.alt = component.data.text || 'Scoreboard Image';
                        img.style.width = '100%';
                        img.style.height = '100%';
                        
                        const scaleMode = component.data.scaleMode || (component.type === 'background' ? 'cover' : 'contain');
                        switch (scaleMode) {
                            case 'cover':
                                img.style.objectFit = 'cover';
                                break;
                            case 'contain':
                                img.style.objectFit = 'contain';
                                break;
                            case 'stretch':
                                img.style.objectFit = 'fill';
                                break;
                            case 'original':
                                img.style.objectFit = 'none';
                                break;
                            default:
                                img.style.objectFit = 'cover';
                        }
                        
                        element.appendChild(img);
                    } else {
                        element.innerHTML = `<div class="placeholder-text">Image (Tauri API not available)</div>`;
                    }
                } catch (error) {
                    console.error('Failed to load image:', error);
                    element.innerHTML = `<div class="placeholder-text">${component.data.text || 'Image not found'}</div>`;
                }
            } else {
                element.innerHTML = `<div class="placeholder-text">No Image</div>`;
            }
            
            container.appendChild(element);
        }

        async function renderVideoComponent(component, container) {
            const element = document.createElement('div');
            element.className = 'video-component';
            element.style.position = 'absolute';
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1;
            
            // Apply styling
            if (component.style) {
                if (component.style.backgroundColor) {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Load video if available
            if (component.data && component.data.videoId) {
                try {
                    if (window.__TAURI__ && window.__TAURI__.core) {
                        const { invoke } = window.__TAURI__.core;
                        const videoData = await invoke('get_video_data', { 
                            videoId: component.data.videoId 
                        });
                        
                        const video = document.createElement('video');
                        video.src = videoData;
                        video.style.width = '100%';
                        video.style.height = '100%';
                        video.playsInline = true;
                        
                        // Apply video properties
                        const videoProps = component.data.videoData || {};
                        video.autoplay = videoProps.autoplay || false;
                        video.loop = videoProps.loop || false;
                        video.muted = videoProps.muted !== false; // Default to muted for autoplay
                        video.controls = videoProps.controls || false;
                        
                        if (videoProps.volume !== undefined) {
                            video.volume = Math.max(0, Math.min(1, videoProps.volume));
                        }
                        if (videoProps.playbackRate !== undefined) {
                            video.playbackRate = videoProps.playbackRate;
                        }
                        
                        // Apply scale mode
                        const scaleMode = component.data.scaleMode || 'cover';
                        switch (scaleMode) {
                            case 'cover':
                                video.style.objectFit = 'cover';
                                break;
                            case 'contain':
                                video.style.objectFit = 'contain';
                                break;
                            case 'stretch':
                                video.style.objectFit = 'fill';
                                break;
                            case 'original':
                                video.style.objectFit = 'none';
                                break;
                            default:
                                video.style.objectFit = 'cover';
                        }
                        
                        element.appendChild(video);
                        
                        // Start playback if autoplay is enabled
                        if (video.autoplay) {
                            video.play().catch(console.error);
                        }
                        
                        console.log(`Loaded video for component:`, component.id, 'Scale mode:', scaleMode);
                    } else {
                        element.innerHTML = `<div class="placeholder-text">Video (Tauri API not available)</div>`;
                    }
                } catch (error) {
                    console.error('Failed to load video:', error);
                    element.innerHTML = `<div class="placeholder-text">${component.data.text || 'Video not found'}</div>`;
                }
            } else {
                element.innerHTML = `<div class="placeholder-text">No Video</div>`;
            }
            
            container.appendChild(element);
        }

        function renderTextComponent(component, container) {
            const element = document.createElement('div');
            element.className = 'text-component';
            element.style.position = 'absolute';
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1000;
            
            // Apply text styling and layout (similar to regular scoreboard)
            element.style.display = 'flex';
            element.style.alignItems = 'center';
            element.style.paddingLeft = '8px';
            element.style.paddingRight = '8px';
            element.style.wordWrap = 'break-word';
            element.style.overflow = 'hidden';
            
            // Apply text alignment
            const textAlign = component.style ? component.style.textAlign || 'center' : 'center';
            switch (textAlign) {
                case 'left':
                    element.style.justifyContent = 'flex-start';
                    element.style.textAlign = 'left';
                    break;
                case 'right':
                    element.style.justifyContent = 'flex-end';
                    element.style.textAlign = 'right';
                    break;
                case 'center':
                default:
                    element.style.justifyContent = 'center';
                    element.style.textAlign = 'center';
                    break;
            }
            
            // Apply text styling
            if (component.style) {
                element.style.fontSize = (component.style.fontSize || 16) + 'px';
                element.style.color = component.style.textColor || '#ffffff';
                element.style.fontWeight = component.style.fontWeight || 'normal';
                element.style.fontFamily = component.style.fontFamily || 'Arial, sans-serif';
                
                if (component.style.backgroundColor && component.style.backgroundColor !== 'transparent') {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity !== undefined) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            element.textContent = component.data.text || 'Sample Text';
            container.appendChild(element);
        }

        function renderTennisComponent(component, container) {
            const element = document.createElement('div');
            element.className = 'text-component tennis-component score-change-base';
            element.style.position = 'absolute';
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1000;
            
            // Apply tennis component styling (similar to regular scoreboard)
            element.style.display = 'flex';
            element.style.alignItems = 'center';
            element.style.paddingLeft = '8px';
            element.style.paddingRight = '8px';
            element.style.wordWrap = 'break-word';
            element.style.overflow = 'hidden';
            
            // Apply text alignment
            const textAlign = component.style ? component.style.textAlign || 'center' : 'center';
            switch (textAlign) {
                case 'left':
                    element.style.justifyContent = 'flex-start';
                    element.style.textAlign = 'left';
                    break;
                case 'right':
                    element.style.justifyContent = 'flex-end';
                    element.style.textAlign = 'right';
                    break;
                case 'center':
                default:
                    element.style.justifyContent = 'center';
                    element.style.textAlign = 'center';
                    break;
            }
            
            // Apply tennis-specific styling
            if (component.style) {
                element.style.fontSize = (component.style.fontSize || 16) + 'px';
                element.style.color = component.style.textColor || '#ffffff';
                element.style.fontWeight = component.style.fontWeight || 'bold';
                element.style.fontFamily = component.style.fontFamily || 'Arial, sans-serif';
                
                if (component.style.backgroundColor && component.style.backgroundColor !== 'transparent') {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity !== undefined) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Get fallback text
            let fallbackText = component.data.text || getDefaultTennisText(component.type, component.data.playerNumber);
            if (component.type === 'tennis_serve_speed' && !component.data.text) {
                fallbackText = '';
            }
            
            element.textContent = fallbackText;
            
            // Setup live data if needed
            // setupLiveDataForComponent(element, component);
            
            container.appendChild(element);
        }

        function getDefaultTennisText(componentType, playerNumber) {
            switch (componentType) {
                case 'tennis_player_name':
                    return `Player ${playerNumber || 1}`;
                case 'tennis_game_score':
                case 'tennis_set_score':
                case 'tennis_match_score':
                case 'tennis_detailed_set_score':
                    return '0';
                case 'tennis_serve_speed':
                    return '';
                default:
                    return 'Tennis Data';
            }
        }

        function renderDefaultComposite(extraInfo = '') {
            const loadingMessage = document.getElementById('loadingMessage');
            
            loadingMessage.innerHTML = `
                <div style="text-align: center;">
                    <h1 style="font-size: 2rem; margin-bottom: 1rem;">Composite Scoreboard Display</h1>
                    <p style="font-size: 1rem; color: #888;">No composite layout loaded</p>
                    <p style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">Create a composite layout to see multiple scoreboards here</p>
                    ${extraInfo ? `<p style="font-size: 0.7rem; color: #555; margin-top: 1rem;">${extraInfo}</p>` : ''}
                </div>
            `;
        }

        function showMessage(message) {
            const loadingMessage = document.getElementById('loadingMessage');
            loadingMessage.innerHTML = `<div>${message}</div><div class="debug-info">${debugInfo ? debugInfo.textContent : ''}</div>`;
            loadingMessage.style.display = 'flex';
        }

        // Start initialization
        document.addEventListener('DOMContentLoaded', () => {
            updateDebug('DOM ready, starting composite scoreboard...');
            initializeCompositeScoreboard();
        });

        window.addEventListener('load', () => {
            if (initAttempts === 0) {
                updateDebug('Window loaded, starting composite scoreboard...');
                initializeCompositeScoreboard();
            }
        });

        // Listen for messages from parent window (if any)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'compositeLayoutData') {
                console.log('Received composite layout data via postMessage:', event.data.data);
                compositeLayout = event.data.data;
                renderCompositeScoreboard(compositeLayout);
            }
        });
    </script>
</body>
</html>