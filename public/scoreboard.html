<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoreboard Display</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #000; 
            color: #fff; 
            overflow: hidden; 
            height: 100vh; 
            width: 100vw; 
            margin: 0;
            padding: 0;
            position: relative;
        }
        .scoreboard-container { 
            position: absolute; 
            background: #000;
            /* Dimensions, scaling and positioning will be set dynamically */
        }
        .image-component {
            position: absolute;
            overflow: hidden;
        }
        .image-component img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .status-indicator { 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            padding: 4px 8px; 
            background: rgba(0,255,136,0.2); 
            border: 1px solid #00ff88; 
            border-radius: 12px; 
            font-size: 0.7rem; 
            font-weight: bold; 
            color: #00ff88; 
            z-index: 1000; 
        }
        .loading-message { 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            font-size: 1.2rem; 
            color: #888; 
            text-align: center;
            padding: 20px;
        }
        .debug-info {
            font-size: 0.8rem;
            color: #666;
            margin-top: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .placeholder-text {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            width: 100%; 
            height: 100%; 
            background: #333; 
            color: #fff; 
            font-size: 12px;
            text-align: center;
            padding: 10px;
        }
        .text-component {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            word-wrap: break-word;
            overflow: hidden;
            padding: 4px;
        }
        .tennis-component {
            /* Specific styling for tennis components */
        }
        .live-data-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        /* Score Change Animation Styles */
        .score-change-base {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-increase {
            animation: scoreIncrease 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-decrease {
            animation: scoreDecrease 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-flash {
            animation: scoreFlash 0.5s ease-out;
        }
        
        .score-glow {
            animation: scoreGlow 1s ease-out;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @keyframes scoreIncrease {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.1);
            }
            100% { 
                transform: scale(1);
            }
        }
        
        @keyframes scoreDecrease {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(0.95);
            }
            100% { 
                transform: scale(1);
            }
        }
        
        @keyframes scoreFlash {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.05);
            }
            100% { 
                transform: scale(1);
            }
        }
        
        @keyframes scoreGlow {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.02);
            }
            100% { 
                transform: scale(1);
            }
        }
        
        /* Smooth transitions */
        .text-component, .tennis-component {
            transition: transform 0.2s ease;
        }
    </style>
</head>
<body>
    <div class="scoreboard-container" id="scoreboardContainer">
        <div class="loading-message" id="loadingMessage">
            <div>Loading Scoreboard...</div>
            <div class="debug-info" id="debugInfo">Initializing...</div>
        </div>
    </div>

    <script>
        let currentWindow = null;
        let scoreboardData = null;
        let debugInfo = document.getElementById('debugInfo');
        let initAttempts = 0;
        const maxInitAttempts = 30; // 30 seconds

        function updateDebug(message) {
            console.log(message);
            if (debugInfo) {
                debugInfo.textContent = message;
            }
        }

        // Try to get window label from URL or other sources
        function getWindowId() {
            // Try to extract from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const windowId = urlParams.get('windowId');
            if (windowId) return windowId;
            
            // Try to get from hash
            const hash = window.location.hash;
            if (hash && hash.startsWith('#')) {
                return hash.substring(1);
            }
            
            // Return null if not found
            return null;
        }

        async function initializeScoreboard() {
            try {
                initAttempts++;
                updateDebug(`Initialization attempt ${initAttempts}/${maxInitAttempts}`);
                
                // First try to use Tauri API if available
                if (window.__TAURI__ && window.__TAURI__.core && window.__TAURI__.webviewWindow) {
                    updateDebug('Using Tauri API...');
                    await initializeWithTauri();
                    return;
                }
                
                // Fallback: Try to get window ID from URL or other sources
                const windowId = getWindowId();
                if (windowId) {
                    updateDebug(`Found window ID: ${windowId}`);
                    // For now, render default scoreboard - we'll improve this
                    renderDefaultScoreboard(`Window: ${windowId}`);
                    return;
                }
                
                // If we still don't have a way to get data, retry or show default
                if (initAttempts < maxInitAttempts) {
                    updateDebug(`Retrying in 1 second... (${initAttempts}/${maxInitAttempts})`);
                    setTimeout(initializeScoreboard, 1000);
                } else {
                    updateDebug('Max attempts reached, showing default');
                    renderDefaultScoreboard();
                }
                
            } catch (error) {
                console.error('Initialization error:', error);
                updateDebug(`Error: ${error.message}`);
                
                if (initAttempts < maxInitAttempts) {
                    setTimeout(initializeScoreboard, 1000);
                } else {
                    showMessage('Failed to initialize: ' + error.message);
                }
            }
        }

        async function initializeWithTauri() {
            const { invoke } = window.__TAURI__.core;
            const { getCurrentWebviewWindow } = window.__TAURI__.webviewWindow;
            
            currentWindow = getCurrentWebviewWindow();
            const windowLabel = currentWindow.label;
            
            updateDebug(`Getting data for window: ${windowLabel}`);
            
            // Get the scoreboard instance data
            const instanceData = await invoke('get_scoreboard_instance_data', { 
                windowId: windowLabel 
            });
            
            console.log('Received instance data:', instanceData);
            
            if (instanceData) {
                scoreboardData = instanceData.scoreboardData || instanceData;
                updateDebug(`Found ${scoreboardData.components ? scoreboardData.components.length : 0} components`);
                await renderScoreboard(scoreboardData);
                // Initialize live data after rendering
                loadLiveDataConnections();
            } else {
                updateDebug('No data found, using default');
                renderDefaultScoreboard();
            }
        }

        let originalDimensions = { width: 800, height: 600 };
        let currentScale = 1;

        async function renderScoreboard(data) {
            const container = document.getElementById('scoreboardContainer');
            const loadingMessage = document.getElementById('loadingMessage');
            
            updateDebug('Rendering custom scoreboard...');
            loadingMessage.style.display = 'none';
            
            // Store original design dimensions with better detection
            if (data.config && data.config.dimensions) {
                originalDimensions = {
                    width: data.config.dimensions.width || 800,
                    height: data.config.dimensions.height || 600
                };
                console.log('Found dimensions in data.config:', originalDimensions);
            } else if (data.dimensions) {
                originalDimensions = {
                    width: data.dimensions.width || 800,
                    height: data.dimensions.height || 600
                };
                console.log('Found dimensions in data.dimensions:', originalDimensions);
            } else {
                console.log('No dimensions found, using default:', originalDimensions);
            }
            
            // Set background
            if (data.background) {
                container.style.backgroundColor = data.background.color || '#000';
            }
            
            // Render components
            if (data.components && data.components.length > 0) {
                for (const component of data.components) {
                    if (component.type === 'background' || component.type === 'logo') {
                        await renderImageComponent(component);
                    } else if (component.type === 'text') {
                        renderTextComponent(component);
                    } else if (component.type === 'tennis_player_name' || 
                               component.type === 'tennis_game_score' || 
                               component.type === 'tennis_set_score' || 
                               component.type === 'tennis_match_score' ||
                               component.type === 'tennis_sets_score') {
                        renderTennisComponent(component);
                    }
                }
            } else {
                showMessage('No components in design');
            }
            
            // Initial scale calculation
            calculateAndApplyScale();
            
            // Add window resize listener for responsive scaling
            window.addEventListener('resize', calculateAndApplyScale);
        }

        function calculateAndApplyScale() {
            const container = document.getElementById('scoreboardContainer');
            if (!container) return;
            
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Minimal padding to maximize space usage
            const padding = 2;
            const availableWidth = Math.max(100, windowWidth - (padding * 2));
            const availableHeight = Math.max(100, windowHeight - (padding * 2));
            
            // Calculate scale factor to fit content in available space while maintaining aspect ratio
            // Account for the 40px margin we added (20px on each side)
            const scaleX = availableWidth / (originalDimensions.width + 40);
            const scaleY = availableHeight / (originalDimensions.height + 40);
            currentScale = Math.min(scaleX, scaleY);
            
            // Ensure minimum scale for very small windows
            currentScale = Math.max(currentScale, 0.1);
            
            // Set the container to original dimensions + margin offset
            // Add 40px (20px on each side) to accommodate the component position offset
            container.style.width = (originalDimensions.width + 40) + 'px';
            container.style.height = (originalDimensions.height + 40) + 'px';
            
            // Apply scaling with top-left origin first
            container.style.transform = `scale(${currentScale})`;
            container.style.transformOrigin = 'top left';
            
            // Calculate the actual size after scaling (including position offset)
            const scaledWidth = (originalDimensions.width + 40) * currentScale;
            const scaledHeight = (originalDimensions.height + 40) * currentScale;
            
            // Position the container to center the scaled content
            const leftOffset = (windowWidth - scaledWidth) / 2;
            const topOffset = (windowHeight - scaledHeight) / 2;
            
            container.style.left = Math.max(0, leftOffset) + 'px';
            container.style.top = Math.max(0, topOffset) + 'px';
            
            console.log(`Scaling Details:
                Original: ${originalDimensions.width}x${originalDimensions.height}
                Window: ${windowWidth}x${windowHeight}
                Available: ${availableWidth}x${availableHeight}
                Scale: ${currentScale.toFixed(3)}x
                Final size: ${scaledWidth.toFixed(0)}x${scaledHeight.toFixed(0)}
                Position: ${leftOffset.toFixed(0)}, ${topOffset.toFixed(0)}`);
        }

        // Live Data Management
        let liveDataConnections = [];
        let activeDataSources = {};
        let pollingIntervals = {};

        async function loadLiveDataConnections() {
            try {
                if (!window.__TAURI__ || !window.__TAURI__.core) {
                    console.log('Tauri not available, skipping live data setup');
                    return;
                }

                // In a real implementation, we'd load connections from storage
                // For now, we'll check if there are any active connections from the main app
                console.log('Live data setup ready for scoreboard display');
            } catch (error) {
                console.error('Failed to load live data connections:', error);
            }
        }

        async function setupLiveDataForComponent(element, component) {
            // Check if this component has live data binding in its data
            // The binding might be stored in different places depending on how it was saved
            let binding = null;
            
            if (component.data && component.data.liveDataBinding) {
                binding = component.data.liveDataBinding;
            } else if (component.liveDataBinding) {
                binding = component.liveDataBinding;
            } else {
                // Check if there's a mock binding for demo purposes (tennis components with mock data)
                if (component.type.startsWith('tennis_') && component.data && component.data.playerNumber) {
                    // Create a mock binding for demo
                    const playerNumber = component.data.playerNumber || 1;
                    let dataPath = '';
                    
                    switch (component.type) {
                        case 'tennis_player_name':
                            dataPath = `player${playerNumber}.name`;
                            break;
                        case 'tennis_game_score':
                            dataPath = `score.player${playerNumber}Points`;
                            break;
                        case 'tennis_set_score':
                            dataPath = `score.player${playerNumber}Games`;
                            break;
                        case 'tennis_match_score':
                            dataPath = `score.player${playerNumber}Sets`;
                            break;
                    }
                    
                    if (dataPath) {
                        binding = {
                            connectionId: 'mock_connection',
                            dataPath: dataPath
                        };
                    }
                }
            }

            if (!binding) {
                return; // No live data binding
            }
            
            // Add live data indicator
            const indicator = document.createElement('div');
            indicator.className = 'live-data-indicator';
            indicator.title = 'Live Data Active';
            element.appendChild(indicator);

            // Setup polling for this component's data
            if (binding.connectionId && binding.dataPath) {
                pollLiveDataForComponent(element, component, binding);
            }
        }

        async function pollLiveDataForComponent(element, component, binding) {
            if (!window.__TAURI__ || !window.__TAURI__.core) {
                console.log('Tauri not available for live data polling');
                return;
            }

            const pollData = async () => {
                try {
                    // This would need to be connected to the live data store
                    // For now, we'll simulate with mock data
                    if (binding.connectionId.includes('mock') || binding.connectionId === 'mock_connection') {
                        const mockData = getMockTennisData();
                        const value = getValueFromDataPath(mockData, binding.dataPath);
                        if (value !== undefined) {
                            // Update the text content directly (element contains the text)
                            const textNodes = element.childNodes;
                            if (textNodes.length > 0) {
                                // Find the text node and update it
                                for (let node of textNodes) {
                                    if (node.nodeType === Node.TEXT_NODE) {
                                        node.textContent = String(value);
                                        break;
                                    }
                                }
                            } else {
                                element.textContent = String(value);
                            }
                            console.log(`Updated ${component.type} with live data:`, value);
                        }
                    }
                } catch (error) {
                    console.error('Failed to poll live data:', error);
                }
            };

            // Initial fetch
            pollData();
            
            // Set up polling interval (5 seconds for demo purposes)
            const interval = setInterval(pollData, 5000);
            pollingIntervals[component.id] = interval;
        }

        function getValueFromDataPath(data, path) {
            return path.split('.').reduce((current, key) => {
                return current && current[key] !== undefined ? current[key] : undefined;
            }, data);
        }

        function getMockTennisData() {
            return {
                matchId: "live_match_001",
                player1: {
                    name: "Novak Djokovic",
                    country: "SRB",
                    seed: 1
                },
                player2: {
                    name: "Rafael Nadal", 
                    country: "ESP",
                    seed: 2
                },
                score: {
                    player1Sets: 2,
                    player2Sets: 1,
                    player1Games: Math.floor(Math.random() * 7), // Randomize for demo
                    player2Games: Math.floor(Math.random() * 7),
                    player1Points: ["0", "15", "30", "40"][Math.floor(Math.random() * 4)],
                    player2Points: ["0", "15", "30", "40"][Math.floor(Math.random() * 4)]
                },
                sets: [
                    { player1Games: 6, player2Games: 4, completed: true },
                    { player1Games: 5, player2Games: 7, completed: true },
                    { player1Games: 7, player2Games: 5, completed: true },
                    { player1Games: Math.floor(Math.random() * 7), player2Games: Math.floor(Math.random() * 7), completed: false }
                ],
                matchStatus: "in_progress",
                servingPlayer: Math.random() > 0.5 ? 1 : 2,
                currentSet: 4,
                isTiebreak: false
            };
        }

        // Cleanup intervals when window is closed
        window.addEventListener('beforeunload', () => {
            Object.values(pollingIntervals).forEach(interval => {
                clearInterval(interval);
            });
        });

        async function renderImageComponent(component) {
            const container = document.getElementById('scoreboardContainer');
            
            const element = document.createElement('div');
            element.className = 'image-component';
            element.style.position = 'absolute';
            // Add 20px offset to match design canvas margin
            element.style.left = (component.position.x + 20) + 'px';
            element.style.top = (component.position.y + 20) + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1;
            
            // Apply styling
            if (component.style) {
                if (component.style.backgroundColor) {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Load image if available
            if (component.data && component.data.imageId) {
                try {
                    if (window.__TAURI__ && window.__TAURI__.core) {
                        const { invoke } = window.__TAURI__.core;
                        const imageData = await invoke('get_image_data', { 
                            imageId: component.data.imageId 
                        });
                        
                        const img = document.createElement('img');
                        img.src = imageData;
                        img.alt = component.data.text || 'Scoreboard Image';
                        img.style.width = '100%';
                        img.style.height = '100%';
                        
                        // Apply scale mode
                        const scaleMode = component.data.scaleMode || (component.type === 'background' ? 'cover' : 'contain');
                        switch (scaleMode) {
                            case 'cover':
                                img.style.objectFit = 'cover';
                                break;
                            case 'contain':
                                img.style.objectFit = 'contain';
                                break;
                            case 'stretch':
                                img.style.objectFit = 'fill';
                                break;
                            case 'original':
                                img.style.objectFit = 'none';
                                break;
                            default:
                                img.style.objectFit = 'cover';
                        }
                        
                        element.appendChild(img);
                        
                        console.log(`Loaded ${component.type} image for component:`, component.id, 'Scale mode:', scaleMode);
                    } else {
                        // Fallback: show placeholder
                        element.innerHTML = `<div class="placeholder-text">Image (Tauri API not available)</div>`;
                    }
                } catch (error) {
                    console.error('Failed to load image:', error);
                    element.innerHTML = `<div class="placeholder-text">${component.data.text || 'Image not found'}</div>`;
                }
            } else {
                element.innerHTML = `<div class="placeholder-text">No Image</div>`;
            }
            
            container.appendChild(element);
        }

        function renderTextComponent(component) {
            const container = document.getElementById('scoreboardContainer');
            
            const element = document.createElement('div');
            element.className = 'text-component';
            element.style.position = 'absolute';
            // Add 20px offset to match design canvas margin
            element.style.left = (component.position.x + 20) + 'px';
            element.style.top = (component.position.y + 20) + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1000; // Text always on top
            
            // Apply flexbox layout (matching design canvas)
            element.style.display = 'flex';
            element.style.alignItems = 'center';
            element.style.paddingLeft = '8px';
            element.style.paddingRight = '8px';
            element.style.wordWrap = 'break-word';
            element.style.overflow = 'hidden';
            
            // Apply text alignment
            const textAlign = component.style ? component.style.textAlign || 'center' : 'center';
            switch (textAlign) {
                case 'left':
                    element.style.justifyContent = 'flex-start';
                    element.style.textAlign = 'left';
                    break;
                case 'right':
                    element.style.justifyContent = 'flex-end';
                    element.style.textAlign = 'right';
                    break;
                case 'center':
                default:
                    element.style.justifyContent = 'center';
                    element.style.textAlign = 'center';
                    break;
            }
            
            // Apply text styling
            if (component.style) {
                element.style.fontSize = (component.style.fontSize || 16) + 'px';
                element.style.color = component.style.textColor || '#ffffff';
                element.style.fontWeight = component.style.fontWeight || 'normal';
                element.style.fontFamily = component.style.fontFamily || 'Arial, sans-serif';
                
                if (component.style.backgroundColor && component.style.backgroundColor !== 'transparent') {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity !== undefined) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Set text content
            element.textContent = component.data.text || 'Sample Text';
            
            container.appendChild(element);
        }

        function renderTennisComponent(component) {
            const container = document.getElementById('scoreboardContainer');
            
            const element = document.createElement('div');
            element.className = 'text-component tennis-component score-change-base';
            element.style.position = 'absolute';
            // Add 20px offset to match design canvas margin
            element.style.left = (component.position.x + 20) + 'px';
            element.style.top = (component.position.y + 20) + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1000;
            
            // Apply flexbox layout (matching design canvas)
            element.style.display = 'flex';
            element.style.alignItems = 'center';
            element.style.paddingLeft = '8px';
            element.style.paddingRight = '8px';
            element.style.wordWrap = 'break-word';
            element.style.overflow = 'hidden';
            
            // Apply text alignment
            const textAlign = component.style ? component.style.textAlign || 'center' : 'center';
            switch (textAlign) {
                case 'left':
                    element.style.justifyContent = 'flex-start';
                    element.style.textAlign = 'left';
                    break;
                case 'right':
                    element.style.justifyContent = 'flex-end';
                    element.style.textAlign = 'right';
                    break;
                case 'center':
                default:
                    element.style.justifyContent = 'center';
                    element.style.textAlign = 'center';
                    break;
            }
            
            // Apply text styling with tennis-specific defaults
            if (component.style) {
                element.style.fontSize = (component.style.fontSize || 16) + 'px';
                element.style.color = component.style.textColor || '#ffffff';
                element.style.fontWeight = component.style.fontWeight || 'bold'; // Bold by default for tennis
                element.style.fontFamily = component.style.fontFamily || 'Arial, sans-serif';
                
                if (component.style.backgroundColor && component.style.backgroundColor !== 'transparent') {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity !== undefined) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Get fallback text based on component type
            let fallbackText = component.data.text || getDefaultTennisText(component.type, component.data.playerNumber);
            
            // Set initial fallback text
            element.textContent = fallbackText;
            
            // Setup live data if this component has a binding
            setupLiveDataForComponent(element, component);
            
            // Add tennis component identifier for future live data updates
            element.setAttribute('data-component-id', component.id);
            element.setAttribute('data-component-type', component.type);
            element.setAttribute('data-player-number', component.data.playerNumber || 1);
            
            container.appendChild(element);
        }

        function getDefaultTennisText(componentType, playerNumber) {
            switch (componentType) {
                case 'tennis_player_name':
                    return `Player ${playerNumber || 1}`;
                case 'tennis_game_score':
                    return '0';
                case 'tennis_set_score':
                    return '0';
                case 'tennis_match_score':
                    return '0';
                case 'tennis_sets_score':
                    return '6-4, 5-7';
                default:
                    return 'Tennis Data';
            }
        }

        function renderDefaultScoreboard(extraInfo = '') {
            const loadingMessage = document.getElementById('loadingMessage');
            
            loadingMessage.innerHTML = `
                <div style="text-align: center;">
                    <h1 style="font-size: 2rem; margin-bottom: 1rem;">Scoreboard Display</h1>
                    <p style="font-size: 1rem; color: #888;">No custom design loaded</p>
                    <p style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">Create a design with image components to see it here</p>
                    ${extraInfo ? `<p style="font-size: 0.7rem; color: #555; margin-top: 1rem;">${extraInfo}</p>` : ''}
                </div>
            `;
        }

        function showMessage(message) {
            const loadingMessage = document.getElementById('loadingMessage');
            loadingMessage.innerHTML = `<div>${message}</div><div class="debug-info">${debugInfo ? debugInfo.textContent : ''}</div>`;
            loadingMessage.style.display = 'flex';
        }

        // Start initialization
        document.addEventListener('DOMContentLoaded', () => {
            updateDebug('DOM ready, starting...');
            initializeScoreboard();
        });

        // Also try on window load
        window.addEventListener('load', () => {
            if (initAttempts === 0) {
                updateDebug('Window loaded, starting...');
                initializeScoreboard();
            }
        });

        // Listen for messages from parent window (if any)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'scoreboardData') {
                console.log('Received scoreboard data via postMessage:', event.data.data);
                scoreboardData = event.data.data;
                renderScoreboard(scoreboardData);
            }
        });
    </script>
</body>
</html>