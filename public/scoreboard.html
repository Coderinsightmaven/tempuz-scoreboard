<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scoreboard Display</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #000; 
            color: #fff; 
            overflow: hidden; 
            height: 100vh; 
            width: 100vw; 
            margin: 0;
            padding: 0;
            position: relative;
        }
        .scoreboard-container { 
            position: absolute; 
            background: #000;
            /* Dimensions, scaling and positioning will be set dynamically */
        }
        .image-component {
            position: absolute;
            overflow: hidden;
        }
        .image-component img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        /* Status indicators removed to prevent visual clutter */
        .loading-message { 
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            font-size: 1.2rem; 
            color: #888; 
            text-align: center;
            padding: 20px;
        }
        .debug-info {
            font-size: 0.8rem;
            color: #666;
            margin-top: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .placeholder-text {
            display: flex; 
            align-items: center; 
            justify-content: center; 
            width: 100%; 
            height: 100%; 
            background: #333; 
            color: #fff; 
            font-size: 12px;
            text-align: center;
            padding: 10px;
        }
        .text-component {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 4px;
        }
        /* Tennis component styling removed to prevent visual clutter */
        .video-component {
            position: absolute;
            overflow: hidden;
        }
        .video-component video {
            width: 100%;
            height: 100%;
        }
        .video-component .video-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            background: #333;
            color: #fff;
            font-size: 12px;
            text-align: center;
            padding: 10px;
        }
        /* Live data indicator removed to prevent visual clutter */
        
        /* Score Change Animation Styles */
        .score-change-base {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-increase {
            animation: scoreIncrease 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-decrease {
            animation: scoreDecrease 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .score-flash {
            animation: scoreFlash 0.6s ease-out;
        }
        
        .score-glow {
            animation: scoreGlow 1s ease-out;
        }
        

        
        /* Pulse animation removed to prevent visual clutter */
        
        @keyframes scoreIncrease {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.1);
            }
            100% { 
                transform: scale(1);
            }
        }
        
        @keyframes scoreDecrease {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(0.95);
            }
            100% { 
                transform: scale(1);
            }
        }
        
        @keyframes scoreFlash {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.05);
            }
            100% { 
                transform: scale(1);
            }
        }
        
        @keyframes scoreGlow {
            0% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.02);
            }
            100% { 
                transform: scale(1);
            }
        }
        

        
        /* Smooth transitions */
        .text-component, .tennis-component {
            transition: transform 0.2s ease;
        }
        
        /* Ensure animations work well with existing styles */
        .score-change-base, .tennis-component {
            will-change: transform;
        }

        /* Serving Indicator Styles - Simple solid dot */
        .serving-side-1,
        .serving-side-2 {
            /* No background, shadow, or animation - just solid dot */
        }

        /* Prevent text wrapping for tennis components */
        .tennis-component {
            white-space: nowrap !important;
            text-overflow: ellipsis;
        }

        /* Serving indicator text styling */
        .tennis-component.serving-side-1,
        .tennis-component.serving-side-2,
        .tennis-component[data-component-type="tennis_serving_indicator"] {
            font-weight: bold;
            font-size: 40px !important;
            /* Simple text without shadow for cleaner look */
        }
    </style>
</head>
<body>
    <div class="scoreboard-container" id="scoreboardContainer">
        <div class="loading-message" id="loadingMessage">
            <div>Loading Scoreboard...</div>
            <div class="debug-info" id="debugInfo">Initializing...</div>
        </div>

        <!-- Tennis API Connection Status Indicator -->
        <!-- Tennis API indicator removed to prevent visual clutter -->
    </div>

    <!-- Socket.IO removed - WebSocket connections now handled by backend (Tauri) -->

    <script>
        let currentWindow = null;
        let scoreboardData = null;
        let debugInfo = document.getElementById('debugInfo');
        let initAttempts = 0;
        const maxInitAttempts = 30; // 30 seconds

        function updateDebug(message) {
            console.log(message);
            if (debugInfo) {
                debugInfo.textContent = message;
            }
        }

        // Try to get window label from URL or other sources
        function getWindowId() {
            // Try to extract from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const windowId = urlParams.get('windowId');
            if (windowId) return windowId;
            
            // Try to get from hash
            const hash = window.location.hash;
            if (hash && hash.startsWith('#')) {
                return hash.substring(1);
            }
            
            // Return null if not found
            return null;
        }

        async function initializeScoreboard() {
            try {
                initAttempts++;
                updateDebug(`Initialization attempt ${initAttempts}/${maxInitAttempts}`);
                
                // First try to use Tauri API if available
                if (window.__TAURI__ && window.__TAURI__.core && window.__TAURI__.webviewWindow) {
                    updateDebug('Using Tauri API...');
                    await initializeWithTauri();
                    return;
                }
                
                // Fallback: Try to get window ID from URL or other sources
                const windowId = getWindowId();
                if (windowId) {
                    updateDebug(`Found window ID: ${windowId}`);
                    // For now, render default scoreboard - we'll improve this
                    renderDefaultScoreboard(`Window: ${windowId}`);
                    return;
                }
                
                // If we still don't have a way to get data, retry or show default
                if (initAttempts < maxInitAttempts) {
                    updateDebug(`Retrying in 1 second... (${initAttempts}/${maxInitAttempts})`);
                    setTimeout(initializeScoreboard, 1000);
                } else {
                    updateDebug('Max attempts reached, showing default');
                    renderDefaultScoreboard();
                }
                
            } catch (error) {
                console.error('Initialization error:', error);
                updateDebug(`Error: ${error.message}`);
                
                if (initAttempts < maxInitAttempts) {
                    setTimeout(initializeScoreboard, 1000);
                } else {
                    showMessage('Failed to initialize: ' + error.message);
                }
            }
        }

        async function initializeWithTauri() {
            const { invoke } = window.__TAURI__.core;
            const { getCurrentWebviewWindow } = window.__TAURI__.webviewWindow;
            
            currentWindow = getCurrentWebviewWindow();
            const windowLabel = currentWindow.label;
            
            updateDebug(`Getting data for window: ${windowLabel}`);
            
            // Get the scoreboard instance data
            const instanceData = await invoke('get_scoreboard_instance_data', { 
                windowId: windowLabel 
            });
            
            console.log('Received instance data:', instanceData);
            
            if (instanceData) {
                scoreboardData = instanceData.scoreboardData || instanceData;
                console.log('ðŸŽ¾ [SCOREBOARD] Received scoreboard data:', scoreboardData);
                updateDebug(`Found ${scoreboardData.components ? scoreboardData.components.length : 0} components`);

                // WebSocket connection handled by backend (Tauri)
                console.log('ðŸŽ¾ [SCOREBOARD] WebSocket connection handled by backend');
                updateDebug('WebSocket handled by backend');

                await renderScoreboard(scoreboardData);
                // Initialize live data after rendering
                loadLiveDataConnections();
            } else {
                updateDebug('No data found, using default');
                renderDefaultScoreboard();
            }
        }

        let originalDimensions = { width: 800, height: 600 };
        let currentScale = 1;

        async function renderScoreboard(data) {
            const container = document.getElementById('scoreboardContainer');
            const loadingMessage = document.getElementById('loadingMessage');
            
            updateDebug('Rendering custom scoreboard...');
            loadingMessage.style.display = 'none';
            
            // Store original design dimensions with better detection
            if (data.config && data.config.dimensions) {
                originalDimensions = {
                    width: data.config.dimensions.width || 800,
                    height: data.config.dimensions.height || 600
                };
                console.log('Found dimensions in data.config:', originalDimensions);
            } else if (data.dimensions) {
                originalDimensions = {
                    width: data.dimensions.width || 800,
                    height: data.dimensions.height || 600
                };
                console.log('Found dimensions in data.dimensions:', originalDimensions);
            } else {
                console.log('No dimensions found, using default:', originalDimensions);
            }
            
            // Set background
            if (data.background) {
                container.style.backgroundColor = data.background.color || '#000';
            }
            
            // Render components
            if (data.components && data.components.length > 0) {
                for (const component of data.components) {
                    if (component.type === 'background' || component.type === 'logo') {
                        await renderImageComponent(component);
                    } else if (component.type === 'text') {
                        renderTextComponent(component);
                    } else if (component.type === 'video') {
                        await renderVideoComponent(component);
                    } else if (component.type === 'tennis_player_name' ||
                               component.type === 'tennis_team_names' ||
                               component.type === 'tennis_adaptive_team_display' ||
                               component.type === 'tennis_game_score' ||
                               component.type === 'tennis_set_score' ||
                               component.type === 'tennis_match_score' ||
                               component.type === 'tennis_serve_speed' ||
                               component.type === 'tennis_detailed_set_score' ||
                               component.type === 'tennis_serving_indicator') {
                        renderTennisComponent(component);
                    }
                }
            } else {
                showMessage('No components in design');
            }
            
            // Initial scale calculation
            calculateAndApplyScale();
            
            // Add window resize listener for responsive scaling
            window.addEventListener('resize', calculateAndApplyScale);
        }

        function calculateAndApplyScale() {
            const container = document.getElementById('scoreboardContainer');
            if (!container) return;
            
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Calculate scale factors to fill the entire window
            const scaleX = windowWidth / originalDimensions.width;
            const scaleY = windowHeight / originalDimensions.height;
            
            // Use separate scales for X and Y to stretch and fill completely (no black bars)
            container.style.width = originalDimensions.width + 'px';
            container.style.height = originalDimensions.height + 'px';
            
            // Apply scaling to fill the entire window
            container.style.transform = `scaleX(${scaleX}) scaleY(${scaleY})`;
            container.style.transformOrigin = 'top left';
            
            // Position at top-left corner (no centering)
            container.style.left = '0px';
            container.style.top = '0px';
            
            // Store the scale values for component positioning
            currentScale = Math.min(scaleX, scaleY); // For compatibility with existing code
            
            console.log(`Scaling Details:
                Original: ${originalDimensions.width}x${originalDimensions.height}
                Window: ${windowWidth}x${windowHeight}
                Scale X: ${scaleX.toFixed(3)}x
                Scale Y: ${scaleY.toFixed(3)}x
                Mode: Fill entire window (stretch)`);
        }

        // Live Data Management
        let liveDataConnections = [];
        let activeDataSources = {};
        let pollingIntervals = {};

        // WebSocket connection now handled by backend (Tauri)

        async function loadLiveDataConnections() {
            try {
                if (!window.__TAURI__ || !window.__TAURI__.core) {
                    console.log('Tauri not available, skipping live data setup');
                    return;
                }

                // WebSocket connection now handled by backend (Tauri)
                // Frontend WebSocket connection disabled to prevent duplicate connections
                console.log('ðŸŽ¾ [SCOREBOARD] WebSocket connection handled by backend - no frontend connection needed');

                // Check for court filter in scoreboard data
                if (scoreboardData.courtFilter) {
                    console.log('ðŸŽ¾ [SCOREBOARD] Court filter found:', scoreboardData.courtFilter);
                    updateDebug(`Court Filter: ${scoreboardData.courtFilter}`);
                } else {
                    console.log('ðŸŽ¾ [SCOREBOARD] No court filter - will receive all matches');
                    updateDebug('No court filter - all matches');
                }

                // Start polling for IonCourt data updates
                startIonCourtDataPolling();
            } catch (error) {
                console.error('Failed to load live data connections:', error);
            }
        }

        // Poll for IonCourt data updates
        let ionCourtDataInterval = null;

        async function startIonCourtDataPolling() {
            console.log('ðŸŽ¾ [SCOREBOARD] Starting IonCourt data polling...');

            if (scoreboardData.courtFilter) {
                console.log('ðŸŽ¾ [SCOREBOARD] Court filter active:', scoreboardData.courtFilter);
            } else {
                console.log('ðŸŽ¾ [SCOREBOARD] No court filter - listening to all matches');
            }

            // Clear any existing interval
            if (ionCourtDataInterval) {
                clearInterval(ionCourtDataInterval);
            }

            // Poll every 2 seconds for new data
            ionCourtDataInterval = setInterval(async () => {
                try {
                    if (!window.__TAURI__ || !window.__TAURI__.core) {
                        return;
                    }

                    // Get latest IonCourt data directly from backend by court name
                    let latestData = null;
                    if (scoreboardData.courtFilter) {
                        try {
                            console.log('ðŸŽ¾ [SCOREBOARD] Requesting data for court:', scoreboardData.courtFilter);
                            // Call backend directly to get data for this specific court
                            latestData = await window.__TAURI__.core.invoke('get_latest_ioncourt_data_by_court', {
                                courtName: scoreboardData.courtFilter
                            });
                            if (latestData) {
                                console.log('ðŸŽ¾ [SCOREBOARD] Retrieved data from backend for court:', scoreboardData.courtFilter, latestData);
                            } else {
                                console.log('ðŸŽ¾ [SCOREBOARD] No data available for court:', scoreboardData.courtFilter);
                            }
                        } catch (error) {
                            console.error('ðŸŽ¾ [SCOREBOARD] Failed to get data from backend:', error);
                        }
                    } else {
                        console.log('ðŸŽ¾ [SCOREBOARD] No court filter set');
                    }

                    if (latestData) {
                        console.log('ðŸŽ¾ [SCOREBOARD] Received IonCourt data update');
                        console.log('ðŸŽ¾ [SCOREBOARD] Raw data:', latestData);

                        // Convert and update components
                        const convertedMatch = convertIonCourtToMatchFormat(latestData);
                        console.log('ðŸŽ¾ [SCOREBOARD] Converted match data:', convertedMatch);

                            updateTennisComponents(convertedMatch);
                        }
                    } catch (error) {
                    // Silently handle errors - backend might not be ready yet
                    console.log('ðŸŽ¾ [SCOREBOARD] No IonCourt data available yet');
                }
            }, 2000);

            console.log('ðŸŽ¾ [SCOREBOARD] IonCourt data polling started');
        }

        function stopIonCourtDataPolling() {
            if (ionCourtDataInterval) {
                clearInterval(ionCourtDataInterval);
                ionCourtDataInterval = null;
                console.log('ðŸŽ¾ [SCOREBOARD] IonCourt data polling stopped');
            }
        }


        // Helper function to format player score - just show the games score
        function formatPlayerScore(playerScore) {
            return (playerScore || 0).toString();
        }

        // Convert IonCourt match data to the format expected by updateTennisComponents
        function convertIonCourtToMatchFormat(ioncourtMatch) {
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ”„ Converting IonCourt data to match format');

            // Helper function to format player names
            function formatPlayerName(player) {
                if (player?.participant) {
                    const firstName = player.participant.first_name || '';
                    const lastName = player.participant.last_name || '';
                    return `${firstName} ${lastName}`.trim();
                }
                return 'Player';
            }

            // Helper function to format doubles player names (first initial + last name)
            function formatDoublesPlayerName(player) {
                if (player?.participant) {
                    const firstName = player.participant.first_name || '';
                    const lastName = player.participant.last_name || '';
                    // For doubles, take only the last part of compound last names
                    // e.g., "Aburto Perez" becomes "Perez", "Smith" stays "Smith"
                    const lastNameParts = lastName.trim().split(' ');
                    const displayLastName = lastNameParts[lastNameParts.length - 1] || 'Player';

                    // Get first initial and format as "F. Lastname"
                    const firstInitial = firstName.charAt(0).toUpperCase() || '';
                    return firstInitial ? `${firstInitial}. ${displayLastName}` : displayLastName;
                }
                return 'Player';
            }

            // Extract player names - handle both singles and doubles
            let player1Name = '';
            let player2Name = '';

            if (ioncourtMatch.matchType === 'SINGLES') {
                // Singles: each side has 1 player
                player1Name = formatPlayerName(ioncourtMatch.sides?.[0]?.players?.[0]);
                player2Name = formatPlayerName(ioncourtMatch.sides?.[1]?.players?.[0]);
            } else if (ioncourtMatch.matchType === 'DOUBLES') {
                // Doubles: each side has 2 players
                const side1Players = ioncourtMatch.sides?.[0]?.players || [];
                const side2Players = ioncourtMatch.sides?.[1]?.players || [];

                // Format doubles names as "F. LastName1 / F. LastName2" (first initial + last name with spaces)
                const side1Names = side1Players.map(p => formatDoublesPlayerName(p)).filter(name => name !== 'Player');
                const side2Names = side2Players.map(p => formatDoublesPlayerName(p)).filter(name => name !== 'Player');

                player1Name = side1Names.join(' / ') || 'Team 1';
                player2Name = side2Names.join(' / ') || 'Team 2';
                    } else {
                // Fallback for unknown match type
                player1Name = 'Player 1';
                player2Name = 'Player 2';
            }

            // Extract team names from the 'note' field in sides
            let team1Name = '';
            let team2Name = '';

            if (ioncourtMatch.sides && ioncourtMatch.sides.length >= 2) {
                team1Name = ioncourtMatch.sides[0]?.note || 'Team 1';
                team2Name = ioncourtMatch.sides[1]?.note || 'Team 2';
                console.log('ðŸŽ¾ [SCOREBOARD] Extracted team names from note fields:', {
                    team1Name,
                    team2Name
                });
            } else {
                console.log('ðŸŽ¾ [SCOREBOARD] No sides data available for team names, using defaults');
                team1Name = 'Team 1';
                team2Name = 'Team 2';
            } 

            // Extract serving side information from IonCourt data
            const server = ioncourtMatch.score?.server;
            console.log('ðŸŽ¾ [SCOREBOARD] ===== SERVING SIDE ANALYSIS =====');
            console.log('ðŸŽ¾ [SCOREBOARD] Raw server data:', server);

            // Extract key serving information
            const servingSide = server?.sideNumber;
            const servingPlayerOnSide = server?.playerNumber;
            const returningSide = server?.returningSide;

            console.log('ðŸŽ¾ [SCOREBOARD] Serving side:', servingSide);
            console.log('ðŸŽ¾ [SCOREBOARD] Serving player on side:', servingPlayerOnSide);
            console.log('ðŸŽ¾ [SCOREBOARD] Returning side:', returningSide);

            // Map serving side to our player numbering (1 or 2)
            const servingPlayer = servingSide === 1 ? 1 : (servingSide === 2 ? 2 : null);
            console.log('ðŸŽ¾ [SCOREBOARD] Calculated servingPlayer (our numbering):', servingPlayer);
            console.log('ðŸŽ¾ [SCOREBOARD] ================================');

            // Calculate sets won and detailed set information
            const sets = ioncourtMatch.score?.sets || [];
            let player1SetsWon = 0;
            let player2SetsWon = 0;
            let detailedSetScores = [];
            let currentSet = 1;

            // Process each set for better formatting
            sets.forEach((set, index) => {
                const setNumber = set.setNumber || (index + 1);
                const side1Score = set.side1Score || 0;
                const side2Score = set.side2Score || 0;
                const side1Tiebreak = set.side1TiebreakScore;
                const side2Tiebreak = set.side2TiebreakScore;
                const isCompleted = set.isCompleted || false;

                // Count sets won (only for completed sets)
                if (isCompleted) {
                    if (side1Score > side2Score) {
                        player1SetsWon++;
                    } else if (side2Score > side1Score) {
                        player2SetsWon++;
                    }
                }

                // Format detailed set score - just show the final games score
                let setScoreString = `${side1Score}-${side2Score}`;

                detailedSetScores.push({
                    setNumber: setNumber,
                    score: setScoreString,
                    isCompleted: isCompleted,
                    side1Score: side1Score,
                    side2Score: side2Score,
                    side1Tiebreak: side1Tiebreak,
                    side2Tiebreak: side2Tiebreak
                });

                // Determine current set (first incomplete set)
                if (!isCompleted && currentSet === 1) {
                    currentSet = setNumber;
                }
            });

            // If all sets are complete, current set is the next one
            if (currentSet === 1 && sets.length > 0) {
                const lastSet = sets[sets.length - 1];
                if (lastSet && lastSet.isCompleted) {
                    currentSet = (lastSet.setNumber || sets.length) + 1;
                }
            }

            console.log('ðŸŽ¾ [SCOREBOARD] Match type:', ioncourtMatch.matchType);
            if (ioncourtMatch.matchType === 'DOUBLES') {
                console.log('ðŸŽ¾ [SCOREBOARD] Player 1 (doubles):', player1Name, '(first initial + last name)');
                console.log('ðŸŽ¾ [SCOREBOARD] Player 2 (doubles):', player2Name, '(first initial + last name)');
                console.log('ðŸŽ¾ [SCOREBOARD] Example: "M. Brown / J. Perez" vs "N. Agritellley / A. Ahmad"');
            } else {
                console.log('ðŸŽ¾ [SCOREBOARD] Player 1 (singles):', player1Name, '(full name)');
                console.log('ðŸŽ¾ [SCOREBOARD] Player 2 (singles):', player2Name, '(full name)');
                console.log('ðŸŽ¾ [SCOREBOARD] Example: "Mike Brown" vs "Nicolas Agritellley"');
            }
            console.log('ðŸŽ¾ [SCOREBOARD] Current score:', ioncourtMatch.score?.side1PointScore, '-', ioncourtMatch.score?.side2PointScore);
            console.log('ðŸŽ¾ [SCOREBOARD] Match score:', ioncourtMatch.score?.scoreStringSide1, '-', ioncourtMatch.score?.scoreStringSide2);
            console.log('ðŸŽ¾ [SCOREBOARD] Serving player:', servingPlayer);
            console.log('ðŸŽ¾ [SCOREBOARD] Server details:', ioncourtMatch.score?.server);

            console.log('ðŸŽ¾ [SCOREBOARD] Sets analysis:', {
                totalSets: sets.length,
                player1SetsWon: player1SetsWon,
                player2SetsWon: player2SetsWon,
                currentSet: currentSet,
                detailedSetScores: detailedSetScores.map(s => `${s.setNumber}: ${s.score}${s.isCompleted ? ' (completed)' : ' (in progress)'}`)
            });

            // Create individual set variables for separate display
            const individualSets = {};
            detailedSetScores.forEach((set, index) => {
                const setNum = set.setNumber || (index + 1);
                individualSets[`set${setNum}`] = {
                    score: set.score,                    // "6-4" or "6-4(7)"
                    player1Score: set.side1Score,         // Player 1's games in this set
                    player2Score: set.side2Score,         // Player 2's games in this set
                    player1Tiebreak: set.side1Tiebreak,   // Player 1's tiebreak score
                    player2Tiebreak: set.side2Tiebreak,   // Player 2's tiebreak score
                    side1Score: set.side1Score,           // Legacy support
                    side2Score: set.side2Score,           // Legacy support
                    side1Tiebreak: set.side1Tiebreak,     // Legacy support
                    side2Tiebreak: set.side2Tiebreak,     // Legacy support
                    isCompleted: set.isCompleted,
                    setNumber: setNum
                };
            });

            // Show example of how sets will display in components
            if (detailedSetScores.length > 0) {
                const setsDisplayExample = detailedSetScores.map(s => s.score).join(', ');
                console.log('ðŸŽ¾ [SCOREBOARD] Sets display example:', setsDisplayExample);
                console.log('ðŸŽ¾ [SCOREBOARD] Component examples:');
                console.log('  - tennis_set_score (P1):', player1SetsWon);
                console.log('  - tennis_set_score (P2):', player2SetsWon);
                console.log('  - tennis_current_set:', currentSet);
                console.log('  - tennis_detailed_set_score:', setsDisplayExample);
                // Show enhanced detailed set score using individual player scores
                console.log('  - tennis_detailed_set_score (enhanced): Single score per component');
                console.log('    Example: Player 1 Set 1 = "6", Player 2 Set 1 = "4"');

                    // Show individual set variables
                console.log('ðŸŽ¾ [SCOREBOARD] Individual set variables:');
                Object.keys(individualSets).forEach(setKey => {
                    const setData = individualSets[setKey];
                    console.log(`  - ${setKey}: "${setData.score}" (${setData.isCompleted ? 'completed' : 'in progress'})`);
                });

                console.log('ðŸŽ¾ [SCOREBOARD] Individual set component examples:');
                for (let i = 1; i <= 5; i++) {
                    const setKey = `set${i}`;
                    if (individualSets[setKey]) {
                        console.log(`  - tennis_set_${i}: "${individualSets[setKey].score}"`);
                    } else {
                        console.log(`  - tennis_set_${i}: "" (empty)`);
                    }
                }

                console.log('ðŸŽ¾ [SCOREBOARD] Player-specific set components:');
                console.log('ðŸŽ¾ [SCOREBOARD] Available components: player1_set1, player2_set1, player1_set2, player2_set2, etc.');
                console.log('ðŸŽ¾ [SCOREBOARD] To test: Add <span data-component-type="player1_set1"></span> to your HTML');
                for (let i = 1; i <= 5; i++) {
                    const setKey = `set${i}`;
                    if (individualSets[setKey]) {
                        console.log(`  - player1_set${i}: "${individualSets[setKey].player1Score}"`);
                        console.log(`  - player2_set${i}: "${individualSets[setKey].player2Score}"`);
                    } else {
                        console.log(`  - player1_set${i}: "${i === 1 ? '0' : ''}" (empty)`);
                        console.log(`  - player2_set${i}: "${i === 1 ? '0' : ''}" (empty)`);
                    }
                }

            }

            // Return converted match data in the format expected by updateTennisComponents
            return {
                // Player information
                player1Name: player1Name,
                player2Name: player2Name,

                // Team names from websocket 'note' fields
                team1Name: team1Name,
                team2Name: team2Name,

                // Current game score (points)
                side1PointScore: ioncourtMatch.score?.side1PointScore || '0',
                side2PointScore: ioncourtMatch.score?.side2PointScore || '0',

                // Overall match score strings
                scoreStringSide1: ioncourtMatch.score?.scoreStringSide1 || `${player1SetsWon}-${player2SetsWon}`,
                scoreStringSide2: ioncourtMatch.score?.scoreStringSide2 || `${player2SetsWon}-${player1SetsWon}`,

                // Enhanced serving information
                servingPlayer: servingPlayer,
                servingSide: servingSide,
                servingPlayerOnSide: servingPlayerOnSide,
                returningSide: returningSide,

                // Match metadata
                matchId: ioncourtMatch.matchId,
                matchStatus: ioncourtMatch.matchStatus,
                matchType: ioncourtMatch.matchType,

                // Enhanced sets data
                scoreboardId: 'ioncourt-main', // Default scoreboard ID for IonCourt
                sets: sets,
                currentSet: currentSet,
                setsWon: {
                    player1: player1SetsWon,
                    player2: player2SetsWon
                },
                detailedSetScores: detailedSetScores, // Enhanced set information for components

                // Individual set variables for separate display
                individualSets: individualSets
            };
        }

        function updateTennisComponents(match) {
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ”„ Updating tennis components with match data');

            // Validate match data
            if (!match) {
                console.log('ðŸŽ¾ [SCOREBOARD] âš ï¸ Match data is null or undefined');
                return;
            }

            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ“Š Player 1:', match.player1Name || 'Unknown', 'vs Player 2:', match.player2Name || 'Unknown',
                match.matchType === 'DOUBLES' ? '(doubles - first initial + last name)' : '(singles - full names)');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ† Score:', match.scoreStringSide1 || '0-0', '-', match.scoreStringSide2 || '0-0');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸŽ¾ Current points:', match.side1PointScore || '0', '-', match.side2PointScore || '0');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸŽ¯ Serving Player:', match.servingPlayer || 'Unknown');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ” Serving Player type:', typeof match.servingPlayer);
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ“ Serving Side:', match.servingSide || 'Unknown');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸŽ¾ Serving Player on Side:', match.servingPlayerOnSide || 'Unknown');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ”„ Returning Side:', match.returningSide || 'Unknown');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ“ˆ Sets Won - P1:', match.setsWon?.player1 || 0, 'P2:', match.setsWon?.player2 || 0);
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸŽ® Match Status:', match.matchStatus || 'Unknown', 'Type:', match.matchType || 'Unknown');

            // Find all tennis components and update them
            const tennisComponents = document.querySelectorAll('[data-component-type^="tennis_"]');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸŽ¯ Found', tennisComponents.length, 'tennis components to update');

            // Debug: List all tennis components found by the general selector
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ“‹ General selector found components:');
            tennisComponents.forEach((comp, index) => {
                const compType = comp.getAttribute('data-component-type');
                const compId = comp.getAttribute('data-component-id');
                console.log(`  ${index + 1}. ${compType} (ID: ${compId})`);
            });

            // Log specifically about serving indicator components
            const servingIndicators = document.querySelectorAll('[data-component-type="tennis_serving_indicator"]');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸŽ¾ Found', servingIndicators.length, 'serving indicator components');
            servingIndicators.forEach((indicator, index) => {
                const playerNum = indicator.getAttribute('data-player-number');
                const componentType = indicator.getAttribute('data-component-type');
                const currentText = indicator.textContent || '';
                console.log(`  - Serving indicator ${index + 1}: type="${componentType}", player=${playerNum}, text="${currentText}"`);

                // Check if this indicator should show serving symbol
                const matchServingPlayer = match.servingPlayer;
                const shouldShow = parseInt(playerNum) === matchServingPlayer;
                const expectedSymbol = shouldShow ? 'â—' : '';
                console.log(`    Expected: "${expectedSymbol}" (Player ${playerNum} ${shouldShow ? 'IS' : 'is NOT'} serving)`);
                console.log('    All attributes:', Array.from(indicator.attributes).map(attr => `${attr.name}="${attr.value}"`).join(', '));
            });

            tennisComponents.forEach(component => {
                const componentType = component.getAttribute('data-component-type');
                const playerNumber = parseInt(component.getAttribute('data-player-number')) || 1;
                console.log(`ðŸŽ¾ [SCOREBOARD] Processing component: ${componentType}, ID: ${component.getAttribute('data-component-id')}, player: ${playerNumber}`);

                let newValue = '';

                /*
                IONCOURT COMPONENT TYPES - Maps to converted match data:

                tennis_player_name      â†’ match.player1Name / match.player2Name
                                        Format: "First Last" (singles) or "F. LastName1 / F. LastName2" (doubles)

                tennis_game_score       â†’ match.side1PointScore / match.side2PointScore
                                        Shows: "0", "15", "30", "40"

                tennis_set_score        â†’ match.setsWon.player1 / match.setsWon.player2
                                        Shows number of sets won (e.g., "1", "2")

                tennis_match_score      â†’ match.scoreStringSide1 / match.scoreStringSide2
                                        Shows overall match score: "1-6 0-0 (40-40)"

                tennis_detailed_set_score â†’ match.individualSets (enhanced)
                                        Shows single set score for specific player and set: "6"
                                        Format: "playerScore" (single number)
                                        Attributes: data-player-number and data-set-number

                tennis_set_1            â†’ match.individualSets.set1
                                        Shows first set score: "6-4", "6-4(7)", "0-0"

                tennis_set_2            â†’ match.individualSets.set2
                                        Shows second set score: "4-6", "7-6(3)", ""

                tennis_set_3            â†’ match.individualSets.set3
                                        Shows third set score: "6-3", "", ""

                tennis_set_4            â†’ match.individualSets.set4
                                        Shows fourth set score (for longer matches)

                tennis_set_5            â†’ match.individualSets.set5
                                        Shows fifth set score (for 5-set matches)

                player1_set1            â†’ match.individualSets.set1.player1Score
                                        Shows Player 1's games in set 1: "6", "4", "0"

                player2_set1            â†’ match.individualSets.set1.player2Score
                                        Shows Player 2's games in set 1: "4", "6", "0"

                player1_set2            â†’ match.individualSets.set2.player1Score
                                        Shows Player 1's games in set 2: "6", "", ""

                player2_set2            â†’ match.individualSets.set2.player2Score
                                        Shows Player 2's games in set 2: "4", "", ""

                player1_set3            â†’ match.individualSets.set3.player1Score
                                        Shows Player 1's games in set 3

                player2_set3            â†’ match.individualSets.set3.player2Score
                                        Shows Player 2's games in set 3

                player1_set4            â†’ match.individualSets.set4.player1Score
                                        Shows Player 1's games in set 4 (for longer matches)

                player2_set4            â†’ match.individualSets.set4.player2Score
                                        Shows Player 2's games in set 4

                player1_set5            â†’ match.individualSets.set5.player1Score
                                        Shows Player 1's games in set 5 (for 5-set matches)

                player2_set5            â†’ match.individualSets.set5.player2Score
                                        Shows Player 2's games in set 5

                tennis_serving_indicator â†’ match.servingPlayer, match.servingSide, match.servingPlayerOnSide, match.returningSide
                                        Shows: "â—" when player is serving

                tennis_current_set      â†’ match.currentSet
                                        Shows current set number (e.g., "1", "2", "3")

                tennis_match_status     â†’ match.matchStatus
                                        Shows: "IN_PROGRESS", "COMPLETED", etc.

                tennis_match_type       â†’ match.matchType
                                        Shows: "SINGLES", "DOUBLES"

                Usage: Add data-component-type="tennis_player_name" data-player-number="1"
                */
                switch (componentType) {
                    case 'tennis_player_name':
                        // Maps to: match.player1Name / match.player2Name
                        // Format: "First Last" for singles, "F. LastName1 / F. LastName2" for doubles (first initial + last part of compound last names)
                        newValue = playerNumber === 1 ? (match.player1Name || 'Player 1') : (match.player2Name || 'Player 2');
                        break;
                    case 'tennis_team_names':
                        // Maps to: match.team1Name / match.team2Name (from websocket 'note' fields)
                        // Format: Team names extracted from IonCourt sides[].note fields
                        const teamSelection = parseInt(component.getAttribute('data-team-selection')) || 0;
                        if (teamSelection === 1) {
                            // Show only team 1
                            newValue = match.team1Name || 'Team 1';
                        } else if (teamSelection === 2) {
                            // Show only team 2
                            newValue = match.team2Name || 'Team 2';
                        } else {
                            // Show individual team based on player number
                            newValue = playerNumber === 1 ? (match.team1Name || 'Team 1') : (match.team2Name || 'Team 2');
                        }
                        break;
                    case 'tennis_adaptive_team_display':
                        // Adaptive display: shows school names for doubles, school names + player last names for singles
                        const adaptiveTeamSelection = parseInt(component.getAttribute('data-team-selection')) || 0;

                        let adaptiveTeam1Text = match.team1Name || 'Team 1';
                        let adaptiveTeam2Text = match.team2Name || 'Team 2';

                        // For singles matches, append player last names to school names
                        if (match.matchType === 'SINGLES') {
                            if (match.player1Name && match.player1Name.includes(' ')) {
                                const player1LastName = match.player1Name.split(' ').pop();
                                adaptiveTeam1Text += ' - ' + player1LastName;
                            }
                            if (match.player2Name && match.player2Name.includes(' ')) {
                                const player2LastName = match.player2Name.split(' ').pop();
                                adaptiveTeam2Text += ' - ' + player2LastName;
                            }
                        }
                        // For doubles matches, just show the school names (already set above)

                        if (adaptiveTeamSelection === 1) {
                            newValue = adaptiveTeam1Text;
                        } else if (adaptiveTeamSelection === 2) {
                            newValue = adaptiveTeam2Text;
                        } else {
                            newValue = adaptiveTeam1Text + ' vs ' + adaptiveTeam2Text;
                        }
                        break;
                    case 'tennis_game_score':
                        // Maps to: match.side1PointScore / match.side2PointScore
                        // Shows current game points: "0", "15", "30", "40", "Ad" (advantage)
                        let pointScore = playerNumber === 1 ? (match.side1PointScore || '0') : (match.side2PointScore || '0');
                        // Convert "A" to "Ad" for advantage scoring
                        if (pointScore === 'A') {
                            pointScore = 'Ad';
                        }
                        newValue = pointScore;
                        break;
                    case 'tennis_set_score':
                        // Maps to: match.setsWon.player1 / match.setsWon.player2
                        // Shows number of sets won by this player
                        if (match.setsWon) {
                            newValue = (playerNumber === 1 ? match.setsWon.player1 : match.setsWon.player2).toString();
                        } else {
                            // Enhanced fallback: Use detailedSetScores if available, otherwise count from sets data
                        let setsWon = 0;
                            if (match.detailedSetScores && match.detailedSetScores.length > 0) {
                                // Use the enhanced detailedSetScores for more accurate counting
                                match.detailedSetScores.forEach(set => {
                                    if (set.isCompleted) {
                                        if (playerNumber === 1 && set.side1Score > set.side2Score) {
                                            setsWon++;
                                        } else if (playerNumber === 2 && set.side2Score > set.side1Score) {
                                            setsWon++;
                                        }
                                    }
                                });
                            } else if (match.sets && match.sets.length > 0) {
                                // Original fallback logic
                            match.sets.forEach(set => {
                                    if (set.isCompleted) {
                                const side1Score = set.side1Score || 0;
                                const side2Score = set.side2Score || 0;
                                    if (playerNumber === 1 && side1Score > side2Score) {
                                        setsWon++;
                                    } else if (playerNumber === 2 && side2Score > side1Score) {
                                        setsWon++;
                                    }
                                }
                            });
                        }
                        newValue = setsWon.toString();
                        }
                        break;
                    case 'tennis_match_score':
                        // Maps to: match.scoreStringSide1 / match.scoreStringSide2
                        // Shows overall match score: "1-6 0-0 (40-40)"
                        newValue = playerNumber === 1 ? (match.scoreStringSide1 || '0-0') : (match.scoreStringSide2 || '0-0');
                        break;
                    case 'tennis_detailed_set_score':
                        // Maps to: match.individualSets with specific player and set
                        // Shows score for ONE specific player in ONE specific set
                        // Format: "playerScore" (single number)
                        // Uses: data-player-number and data-set-number attributes
                        const setNumber = parseInt(component.getAttribute('data-set-number')) || 1;
                        console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - component:', component.id, 'setNumber:', setNumber, 'playerNumber:', playerNumber);
                        console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - match.individualSets exists:', !!match.individualSets);

                        if (match.individualSets) {
                            console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - individualSets keys:', Object.keys(match.individualSets));
                            const setKey = `set${setNumber}`;
                            console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - looking for setKey:', setKey);
                            if (match.individualSets[setKey]) {
                                console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - found set data:', match.individualSets[setKey]);
                                // Get the score for the specified player in the specified set
                                const playerScore = playerNumber === 1
                                    ? (match.individualSets[setKey].player1Score || 0)
                                    : (match.individualSets[setKey].player2Score || 0);

                                console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - playerScore:', playerScore);

                                // Just show the games score without tiebreak details
                                let scoreString = playerScore.toString();

                                console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - final scoreString:', scoreString);
                                newValue = scoreString;
                            } else {
                                // Set doesn't exist yet, show 0
                                console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - set not found, using 0');
                                newValue = '0';
                            }
                        } else {
                            console.log('ðŸŽ¾ [SCOREBOARD] tennis_detailed_set_score - individualSets not found, using fallback');
                            if (match.detailedSetScores && match.detailedSetScores.length >= setNumber) {
                                // Fallback: extract from detailed set scores
                                const setData = match.detailedSetScores[setNumber - 1];
                                if (setData) {
                                    const scores = setData.score.split('/');
                                    newValue = playerNumber === 1 ? scores[0] : (scores[1] || scores[0]);
                                } else {
                                    newValue = '0';
                                }
                            } else if (match.sets && match.sets.length >= setNumber) {
                                // Final fallback: extract from basic sets data
                                const setData = match.sets[setNumber - 1];
                                if (setData) {
                                    const playerScore = playerNumber === 1
                                        ? (setData.side1Score || 0)
                                        : (setData.side2Score || 0);

                                    // Just show the games score without tiebreak details
                                    let scoreString = playerScore.toString();

                                    newValue = scoreString;
                                } else {
                                    newValue = '0';
                                }
                            } else {
                                newValue = '0';
                            }
                        }
                        break;
                    case 'tennis_serving_indicator':
                        // Enhanced serving indicator using detailed serving data
                        console.log('ðŸŽ¾ [SCOREBOARD] ===== PROCESSING SERVING INDICATOR =====');
                        console.log('ðŸŽ¾ [SCOREBOARD] Component element:', component);
                        console.log('ðŸŽ¾ [SCOREBOARD] Component ID:', component.getAttribute('data-component-id'));
                        console.log('ðŸŽ¾ [SCOREBOARD] Component playerNumber:', playerNumber);
                        console.log('ðŸŽ¾ [SCOREBOARD] Match servingPlayer:', match.servingPlayer);
                        console.log('ðŸŽ¾ [SCOREBOARD] Match servingSide:', match.servingSide);
                        console.log('ðŸŽ¾ [SCOREBOARD] Match servingPlayerOnSide:', match.servingPlayerOnSide);
                        console.log('ðŸŽ¾ [SCOREBOARD] Match returningSide:', match.returningSide);
                        console.log('ðŸŽ¾ [SCOREBOARD] Component current text:', component.textContent);

                        if (match.servingPlayer === playerNumber) {
                            // Simple serving indicator - just a solid dot
                            newValue = 'â—';

                            console.log('  - RESULT: Showing serving indicator for player', playerNumber);
                            console.log('  - Setting newValue to:', newValue);
                        } else {
                            newValue = '';
                            console.log('  - RESULT: Not showing serving indicator (empty) for player', playerNumber);
                            console.log('  - Setting newValue to:', newValue);
                        }

                        console.log('ðŸŽ¾ [SCOREBOARD] ===== END SERVING INDICATOR PROCESSING =====');
                        break;
                    case 'tennis_current_set':
                        // Maps to: match.currentSet
                        // Shows current set number
                        newValue = (match.currentSet || 1).toString();
                        break;
                    case 'tennis_match_status':
                        // Maps to: match.matchStatus
                        // Shows match status: "IN_PROGRESS", "COMPLETED", etc.
                        newValue = match.matchStatus || 'UNKNOWN';
                        break;
                    case 'tennis_match_type':
                        // Maps to: match.matchType
                        // Shows match type: "SINGLES", "DOUBLES"
                        newValue = match.matchType || 'UNKNOWN';
                        break;

                    // Individual set components for separate display
                    case 'tennis_set_1':
                        // Maps to: match.individualSets.set1
                        // Shows first set score: "6-4", "6-4(7)", "0-0"
                        if (match.individualSets?.set1) {
                            newValue = match.individualSets.set1.score;
                        } else {
                            newValue = '0-0';
                        }
                        break;
                    case 'tennis_set_2':
                        // Maps to: match.individualSets.set2
                        // Shows second set score
                        if (match.individualSets?.set2) {
                            newValue = match.individualSets.set2.score;
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'tennis_set_3':
                        // Maps to: match.individualSets.set3
                        // Shows third set score
                        if (match.individualSets?.set3) {
                            newValue = match.individualSets.set3.score;
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'tennis_set_4':
                        // Maps to: match.individualSets.set4
                        // Shows fourth set score
                        if (match.individualSets?.set4) {
                            newValue = match.individualSets.set4.score;
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'tennis_set_5':
                        // Maps to: match.individualSets.set5
                        // Shows fifth set score
                        if (match.individualSets?.set5) {
                            newValue = match.individualSets.set5.score;
                        } else {
                            newValue = '';
                        }
                        break;

                    // Player-specific set score components for organized display
                    case 'player1_set1':
                        // Maps to: match.individualSets.set1.player1Score
                        // Shows Player 1's games score in set 1
                        if (match.individualSets?.set1) {
                            newValue = formatPlayerScore(match.individualSets.set1.player1Score);
                        } else {
                            newValue = '0';
                        }
                        break;
                    case 'player2_set1':
                        // Maps to: match.individualSets.set1.player2Score
                        // Shows Player 2's games score in set 1
                        if (match.individualSets?.set1) {
                            newValue = formatPlayerScore(match.individualSets.set1.player2Score);
                        } else {
                            newValue = '0';
                        }
                        break;
                    case 'player1_set2':
                        // Maps to: match.individualSets.set2.player1Score
                        // Shows Player 1's games score in set 2
                        if (match.individualSets?.set2) {
                            newValue = formatPlayerScore(match.individualSets.set2.player1Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'player2_set2':
                        // Maps to: match.individualSets.set2.player2Score
                        // Shows Player 2's games score in set 2
                        if (match.individualSets?.set2) {
                            newValue = formatPlayerScore(match.individualSets.set2.player2Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'player1_set3':
                        // Maps to: match.individualSets.set3.player1Score
                        // Shows Player 1's games score in set 3
                        if (match.individualSets?.set3) {
                            newValue = formatPlayerScore(match.individualSets.set3.player1Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'player2_set3':
                        // Maps to: match.individualSets.set3.player2Score
                        // Shows Player 2's games score in set 3
                        if (match.individualSets?.set3) {
                            newValue = formatPlayerScore(match.individualSets.set3.player2Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'player1_set4':
                        // Maps to: match.individualSets.set4.player1Score
                        // Shows Player 1's games score in set 4
                        if (match.individualSets?.set4) {
                            newValue = formatPlayerScore(match.individualSets.set4.player1Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'player2_set4':
                        // Maps to: match.individualSets.set4.player2Score
                        // Shows Player 2's games score in set 4
                        if (match.individualSets?.set4) {
                            newValue = formatPlayerScore(match.individualSets.set4.player2Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'player1_set5':
                        // Maps to: match.individualSets.set5.player1Score
                        // Shows Player 1's games score in set 5
                        if (match.individualSets?.set5) {
                            newValue = formatPlayerScore(match.individualSets.set5.player1Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    case 'player2_set5':
                        // Maps to: match.individualSets.set5.player2Score
                        // Shows Player 2's games score in set 5
                        if (match.individualSets?.set5) {
                            newValue = formatPlayerScore(match.individualSets.set5.player2Score);
                        } else {
                            newValue = '';
                        }
                        break;
                    default:
                        newValue = component.textContent || '';
                }

                // Animate the change if value is different
                if (component.textContent !== newValue) {
                    console.log(`ðŸŽ¾ [SCOREBOARD] ðŸ”„ Updating ${componentType} for Player ${playerNumber}`);
                    console.log(`ðŸŽ¾ [SCOREBOARD] ðŸ“ˆ Value change: "${component.textContent}" â†’ "${newValue}"`);
                    console.log(`ðŸŽ¾ [SCOREBOARD] âœ¨ Animating component update`);
                    console.log(`ðŸŽ¾ [SCOREBOARD] Component ID: ${component.getAttribute('data-component-id')}`);
                } else {
                    console.log(`ðŸŽ¾ [SCOREBOARD] âœ… ${componentType} for Player ${playerNumber} already shows: "${newValue}"`);
                    console.log(`ðŸŽ¾ [SCOREBOARD] Component ID: ${component.getAttribute('data-component-id')}`);
                }

                // Only animate if there's a change
                if (component.textContent !== newValue) {
                    // Add animation class for smooth transition (skip for serving indicators)
                    if (componentType !== 'tennis_serving_indicator') {
                        component.classList.add('score-flash');
                    }

                    // Update the text content
                    const textNodes = component.childNodes;
                    console.log(`ðŸŽ¾ [SCOREBOARD] Component has ${textNodes.length} child nodes`);
                    console.log(`ðŸŽ¾ [SCOREBOARD] Component childNodes:`, Array.from(textNodes).map(node => ({ type: node.nodeType, content: node.textContent })));

                    if (textNodes.length > 0) {
                        let foundTextNode = false;
                        for (let node of textNodes) {
                            if (node.nodeType === Node.TEXT_NODE) {
                                console.log(`ðŸŽ¾ [SCOREBOARD] Updating text node from "${node.textContent}" to "${newValue}"`);
                                node.textContent = newValue;
                                foundTextNode = true;
                                break;
                            }
                        }
                        if (!foundTextNode) {
                            console.log(`ðŸŽ¾ [SCOREBOARD] No text nodes found, using component.textContent`);
                            component.textContent = newValue;
                        }
                    } else {
                        console.log(`ðŸŽ¾ [SCOREBOARD] No child nodes, using component.textContent`);
                        component.textContent = newValue;
                    }

                    console.log(`ðŸŽ¾ [SCOREBOARD] After update, component.textContent = "${component.textContent}"`);

                    // Scale text to maximally fill if it's a player name or adaptive team display component
                    if ((componentType === 'tennis_player_name' && newValue && newValue !== 'Player 1' && newValue !== 'Player 2') ||
                        (componentType === 'tennis_adaptive_team_display' && newValue && newValue !== 'School A - Smith vs School B - Johnson')) {
                        // Get component dimensions from the element's style
                        const componentWidth = parseFloat(component.style.width);
                        const componentHeight = parseFloat(component.style.height);
                        const optimalFontSize = scaleTextToFit(component, componentWidth, componentHeight);
                        component.style.fontSize = optimalFontSize + 'px';
                    }

                    // Additional debugging: Check the DOM element directly
                    const checkElement = document.querySelector(`[data-component-id="${component.getAttribute('data-component-id')}"]`);
                    if (checkElement) {
                        console.log(`ðŸŽ¾ [SCOREBOARD] DOM element check: textContent = "${checkElement.textContent}"`);
                        console.log(`ðŸŽ¾ [SCOREBOARD] DOM element check: innerHTML = "${checkElement.innerHTML}"`);
                        console.log(`ðŸŽ¾ [SCOREBOARD] DOM element check: childNodes length = ${checkElement.childNodes.length}`);
                    }

                    // Remove animation class after animation completes
                    setTimeout(() => {
                        component.classList.remove('score-flash');
                    }, 600);
                } else {
                    console.log(`ðŸŽ¾ [SCOREBOARD] âœ… ${componentType} for Player ${playerNumber} already shows: "${newValue}"`);
                }
            });
        }

        function clearTennisComponents() {
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ§¹ Clearing tennis components to default values');

            const tennisComponents = document.querySelectorAll('[data-component-type^="tennis_"]');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸŽ¯ Clearing', tennisComponents.length, 'tennis components');

            tennisComponents.forEach(component => {
                const componentType = component.getAttribute('data-component-type');
                const playerNumber = parseInt(component.getAttribute('data-player-number')) || 1;

                // Reset to default values matching the live data format
                let defaultValue = '';
                switch (componentType) {
                    case 'tennis_player_name':
                        defaultValue = `Player ${playerNumber}`;
                        break;
                    case 'tennis_team_names':
                        const teamSelection = parseInt(component.getAttribute('data-team-selection')) || 0;
                        if (teamSelection === 1) {
                            defaultValue = 'Team 1';
                        } else if (teamSelection === 2) {
                            defaultValue = 'Team 2';
                        } else {
                            // Show individual team based on player number
                            defaultValue = playerNumber === 1 ? 'Team 1' : 'Team 2';
                        }
                        break;
                    case 'tennis_game_score':
                        defaultValue = '0'; // Point score starts at 0
                        break;
                    case 'tennis_set_score':
                        defaultValue = '0'; // Sets won starts at 0
                        break;
                    case 'tennis_match_score':
                        defaultValue = '0-0'; // Match score string format
                        break;
                    case 'tennis_detailed_set_score':
                        defaultValue = '0'; // Single set score for specific player and set
                        break;
                    case 'tennis_serving_indicator':
                        defaultValue = 'â—'; // Default serving indicator symbol
                        break;
                    case 'tennis_serve_speed':
                        defaultValue = ''; // Empty for serve speed when no data
                        break;
                    default:
                        defaultValue = '';
                }

                console.log(`ðŸŽ¾ [SCOREBOARD] ðŸ”„ Resetting ${componentType} for Player ${playerNumber} to: "${defaultValue}"`);
                component.textContent = defaultValue;
            });

            console.log('ðŸŽ¾ [SCOREBOARD] âœ… All tennis components cleared to default values');
        }

        // updateTennisApiIndicator function removed to prevent visual clutter

        async function setupLiveDataForComponent(element, component) {
            // Check if this component has live data binding in its data
            // The binding might be stored in different places depending on how it was saved
            let binding = null;
            
            if (component.data && component.data.liveDataBinding) {
                binding = component.data.liveDataBinding;
            } else if (component.liveDataBinding) {
                binding = component.liveDataBinding;
            } else {
                // Check if there's a mock binding for demo purposes (tennis components with mock data)
                if (component.type.startsWith('tennis_')) {
                    // Create a mock binding for demo
                    let dataPath = '';
                    
                    if (component.type === 'tennis_serve_speed') {
                        dataPath = 'serve.speed';
                    } else if (component.type === 'tennis_detailed_set_score') {
                        // Detailed set score shows specific set for specific player
                        const playerNumber = component.data.playerNumber || 1;
                        const setNumber = component.data.setNumber || 1;
                        dataPath = `individualSets.set${setNumber}.player${playerNumber}`; // Specific set and player from individualSets
                    } else if (component.data && component.data.playerNumber) {
                        const playerNumber = component.data.playerNumber || 1;
                        
                        switch (component.type) {
                            case 'tennis_player_name':
                                dataPath = `player${playerNumber}.name`;
                                break;
                            case 'tennis_adaptive_team_display':
                                // For adaptive team display, handled specially in updateTennisComponents
                                // No specific dataPath needed - uses full match data
                                dataPath = null;
                                break;
                            case 'tennis_game_score':
                                dataPath = `score.player${playerNumber}Points`;
                                break;
                            case 'tennis_set_score':
                                dataPath = `score.player${playerNumber}Games`;
                                break;
                            case 'tennis_match_score':
                                dataPath = `score.player${playerNumber}Sets`;
                                break;
                        }
                    }
                    
                    if (dataPath) {
                        binding = {
                            connectionId: 'mock_connection',
                            dataPath: dataPath
                        };
                    }
                }
            }

            if (!binding) {
                return; // No live data binding
            }
            
            // Live data indicator removed to prevent visual clutter

            // Setup polling for this component's data
            if (binding.connectionId && binding.dataPath) {
                pollLiveDataForComponent(element, component, binding);
            }
        }

        async function pollLiveDataForComponent(element, component, binding) {
            if (!window.__TAURI__ || !window.__TAURI__.core) {
                console.log('Tauri not available for live data polling');
                return;
            }

            const pollData = async () => {
                try {
                    // MOCK DATA DISABLED - No longer using mock data for live updates
                    /*
                    // This would need to be connected to the live data store
                    // For now, we'll simulate with mock data
                    if (binding.connectionId.includes('mock') || binding.connectionId === 'mock_connection') {
                        const mockData = getMockTennisData();
                        const value = getValueFromDataPath(mockData, binding.dataPath);
                        if (value !== undefined) {
                            // Get current value for comparison
                            const currentValue = element.textContent;
                            const newValue = String(value);

                            // Only update and animate if value actually changed
                            if (currentValue !== newValue) {
                                // Apply transition animation based on component type and change
                                animateValueChange(element, component, currentValue, newValue);

                                // Update the text content
                                const textNodes = element.childNodes;
                                if (textNodes.length > 0) {
                                    // Find the text node and update it
                                    for (let node of textNodes) {
                                        if (node.nodeType === Node.TEXT_NODE) {
                                            node.textContent = newValue;
                                            break;
                                        }
                                    }
                                } else {
                                    element.textContent = newValue;
                                }
                                console.log(`Updated ${component.type} with animated transition: ${currentValue} â†’ ${newValue}`);
                            }
                        }
                    }
                    */
                } catch (error) {
                    console.error('Failed to poll live data:', error);
                }
            };

            // Initial fetch
            pollData();
            
            // Set up polling interval (2 seconds for demo purposes - faster for animation demo)
            const interval = setInterval(pollData, 2000);
            pollingIntervals[component.id] = interval;
        }

        function getValueFromDataPath(data, path) {
            return path.split('.').reduce((current, key) => {
                return current && current[key] !== undefined ? current[key] : undefined;
            }, data);
        }

        function animateValueChange(element, component, oldValue, newValue) {
            // Remove any existing animation classes
            element.classList.remove('score-increase', 'score-decrease', 'score-flash', 'score-glow');
            
            // Skip animations for name/player components
            if (component.type.includes('name') || component.type.includes('player')) {
                console.log(`â­ï¸  Skipping animation for ${component.type}: ${oldValue} â†’ ${newValue}`);
                return;
            }
            
            // Determine animation type based on component type and value change
            let animationClass = 'score-flash'; // Default animation
            let duration = 800; // Default duration
            
            if (component.type.includes('score') || component.type.includes('game') || component.type.includes('set')) {
                // For numeric scores, determine if increasing or decreasing
                const oldNum = parseInt(oldValue) || 0;
                const newNum = parseInt(newValue) || 0;
                
                if (newNum > oldNum) {
                    animationClass = 'score-increase';
                    duration = 800;
                } else if (newNum < oldNum) {
                    animationClass = 'score-decrease';
                    duration = 800;
                } else {
                    animationClass = 'score-glow';
                    duration = 1000;
                }
            } else if (component.type.includes('serve') || component.type.includes('speed')) {
                // For serve speed, use flash animation
                animationClass = 'score-flash';
                duration = 600;
            }
            
            // Apply the animation class
            element.classList.add(animationClass);
            console.log(`ðŸŽ¬ Animating ${component.type}: ${oldValue} â†’ ${newValue} (${animationClass})`);
            
            // Remove animation class after animation completes
            setTimeout(() => {
                element.classList.remove(animationClass);
            }, duration);
        }

        // MOCK DATA FUNCTION DISABLED - No longer generating fake tennis data
        /*
        function getMockTennisData() {
            // Progressive match simulation - starts at set 1 and progresses over time
            const now = Date.now();
            const matchStartTime = window.mockMatchStartTime || (window.mockMatchStartTime = now);
            const matchDuration = now - matchStartTime;

            // Progress through sets over time (each set takes ~30 seconds for demo)
            let currentSet = 1;
            let setsWon = { player1: 0, player2: 0 };
            let setsData = {};

            // Determine current set based on time elapsed
            if (matchDuration > 30000) currentSet = 2; // After 30 seconds, start set 2
            if (matchDuration > 60000) currentSet = 3; // After 60 seconds, start set 3

            // Build sets data progressively
            for (let setNum = 1; setNum <= currentSet; setNum++) {
                if (setNum < currentSet) {
                    // Completed sets
                    const set1Won = setNum === 1 ? 1 : (setNum === 2 ? 2 : 1); // Alternate winners
                    setsData[`set${setNum}`] = {
                        player1: set1Won === 1 ? 6 : 4,
                        player2: set1Won === 2 ? 6 : 4
                    };
                    if (set1Won === 1) setsWon.player1++;
                    else setsWon.player2++;
                } else {
                    // Current set in progress
                    setsData[`set${setNum}`] = {
                        player1: Math.floor(Math.random() * 7),
                        player2: Math.floor(Math.random() * 7)
                    };
                }
            }

            return {
                matchId: "live_match_001",
                player1: {
                    name: "Novak Djokovic",
                    country: "SRB",
                    seed: 1
                },
                player2: {
                    name: "Rafael Nadal",
                    country: "ESP",
                    seed: 2
                },
                score: {
                    player1Sets: setsWon.player1,
                    player2Sets: setsWon.player2,
                    player1Games: setsData[`set${currentSet}`]?.player1 || 0,
                    player2Games: setsData[`set${currentSet}`]?.player2 || 0,
                    player1Points: ["0", "15", "30", "40"][Math.floor(Math.random() * 4)],
                    player2Points: ["0", "15", "30", "40"][Math.floor(Math.random() * 4)]
                },
                sets: setsData,
                serve: {
                    speed: Math.floor(Math.random() * 40) + 100 + " MPH" // 100-140 MPH
                },
                matchStatus: currentSet >= 3 && setsWon.player1 >= 2 || setsWon.player2 >= 2 ? "completed" : "in_progress",
                servingPlayer: Math.random() > 0.5 ? 1 : 2,
                currentSet: currentSet,
                isTiebreak: false
            };
        }
        */

        // Cleanup intervals and WebSocket when window is closed
        window.addEventListener('beforeunload', () => {
            console.log('ðŸŽ¾ Cleaning up scoreboard window...');

            // Clear polling intervals
            Object.values(pollingIntervals).forEach(interval => {
                clearInterval(interval);
            });

            // Stop IonCourt data polling
            stopIonCourtDataPolling();

            // WebSocket disconnect now handled by backend (Tauri)
            // Frontend WebSocket disconnect disabled to prevent duplicate disconnects
            console.log('ðŸŽ¾ WebSocket disconnect handled by backend - no frontend disconnect needed');
        });

        async function renderImageComponent(component) {
            const container = document.getElementById('scoreboardContainer');
            
            const element = document.createElement('div');
            element.className = 'image-component';
            element.style.position = 'absolute';
            // Position component exactly as designed (no offset needed)
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1;
            
            // Apply styling
            if (component.style) {
                if (component.style.backgroundColor) {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Load image if available
            if (component.data && component.data.imageId) {
                try {
                    if (window.__TAURI__ && window.__TAURI__.core) {
                        const { invoke } = window.__TAURI__.core;
                        const imageData = await invoke('get_image_data', { 
                            imageId: component.data.imageId 
                        });
                        
                        const img = document.createElement('img');
                        img.src = imageData;
                        img.alt = component.data.text || 'Scoreboard Image';
                        img.style.width = '100%';
                        img.style.height = '100%';
                        
                        // Apply scale mode
                        const scaleMode = component.data.scaleMode || (component.type === 'background' ? 'cover' : 'contain');
                        switch (scaleMode) {
                            case 'cover':
                                img.style.objectFit = 'cover';
                                break;
                            case 'contain':
                                img.style.objectFit = 'contain';
                                break;
                            case 'stretch':
                                img.style.objectFit = 'fill';
                                break;
                            case 'original':
                                img.style.objectFit = 'none';
                                break;
                            default:
                                img.style.objectFit = 'cover';
                        }
                        
                        element.appendChild(img);
                        
                        console.log(`Loaded ${component.type} image for component:`, component.id, 'Scale mode:', scaleMode);
                    } else {
                        // Fallback: show placeholder
                        element.innerHTML = `<div class="placeholder-text">Image (Tauri API not available)</div>`;
                    }
                } catch (error) {
                    console.error('Failed to load image:', error);
                    element.innerHTML = `<div class="placeholder-text">${component.data.text || 'Image not found'}</div>`;
                }
            } else {
                element.innerHTML = `<div class="placeholder-text">No Image</div>`;
            }
            
            container.appendChild(element);
        }

        async function renderVideoComponent(component) {
            const container = document.getElementById('scoreboardContainer');
            
            const element = document.createElement('div');
            element.className = 'video-component';
            element.style.position = 'absolute';
            // Position component exactly as designed (no offset needed)
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1;
            
            // Apply styling
            if (component.style) {
                if (component.style.backgroundColor) {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Load video if available
            if (component.data && component.data.videoId) {
                try {
                    if (window.__TAURI__ && window.__TAURI__.core) {
                        const { invoke } = window.__TAURI__.core;
                        const videoData = await invoke('get_video_data', { 
                            videoId: component.data.videoId 
                        });
                        
                        const video = document.createElement('video');
                        video.src = videoData;
                        video.style.width = '100%';
                        video.style.height = '100%';
                        video.playsInline = true;
                        
                        // Apply video settings from component data
                        const videoSettings = component.data.videoData || {};
                        video.autoplay = videoSettings.autoplay || false;
                        video.loop = videoSettings.loop || false;
                        video.muted = videoSettings.muted !== false; // default to true
                        video.controls = videoSettings.controls || false;
                        video.volume = videoSettings.volume || 1;
                        video.playbackRate = videoSettings.playbackRate || 1;
                        
                        // Apply scale mode
                        const scaleMode = videoSettings.scaleMode || 'cover';
                        switch (scaleMode) {
                            case 'cover':
                                video.style.objectFit = 'cover';
                                break;
                            case 'contain':
                                video.style.objectFit = 'contain';
                                break;
                            case 'stretch':
                                video.style.objectFit = 'fill';
                                break;
                            case 'original':
                                video.style.objectFit = 'none';
                                break;
                            default:
                                video.style.objectFit = 'cover';
                        }
                        
                        // Handle video errors
                        video.onerror = () => {
                            console.error('Video failed to load');
                            element.innerHTML = `<div class="video-placeholder">Video not found</div>`;
                        };
                        
                        // Try to play the video if autoplay is enabled
                        if (video.autoplay) {
                            video.play().catch(error => {
                                console.log('Autoplay failed:', error);
                                // This is normal - browsers often block autoplay
                            });
                        }
                        
                        element.appendChild(video);
                        
                        console.log(`Loaded video component:`, component.id, 'Settings:', videoSettings);
                    } else {
                        // Fallback: show placeholder
                        element.innerHTML = `<div class="video-placeholder">ðŸŽ¥<br>Video<br>(Tauri API not available)</div>`;
                    }
                } catch (error) {
                    console.error('Failed to load video:', error);
                    element.innerHTML = `<div class="video-placeholder">ðŸŽ¥<br>Video not found</div>`;
                }
            } else {
                element.innerHTML = `<div class="video-placeholder">ðŸŽ¥<br>No Video Selected</div>`;
            }
            
            container.appendChild(element);
        }

        function renderTextComponent(component) {
            const container = document.getElementById('scoreboardContainer');
            
            const element = document.createElement('div');
            element.className = 'text-component';
            element.style.position = 'absolute';
            // Position component exactly as designed (no offset needed)
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1000; // Text always on top
            
            // Apply flexbox layout (matching design canvas)
            element.style.display = 'flex';
            element.style.alignItems = 'center';
            element.style.paddingLeft = '8px';
            element.style.paddingRight = '8px';
            element.style.whiteSpace = 'nowrap';
            element.style.overflow = 'hidden';
            element.style.textOverflow = 'ellipsis';
            
            // Apply text alignment
            const textAlign = component.style ? component.style.textAlign || 'center' : 'center';
            switch (textAlign) {
                case 'left':
                    element.style.justifyContent = 'flex-start';
                    element.style.textAlign = 'left';
                    break;
                case 'right':
                    element.style.justifyContent = 'flex-end';
                    element.style.textAlign = 'right';
                    break;
                case 'center':
                default:
                    element.style.justifyContent = 'center';
                    element.style.textAlign = 'center';
                    break;
            }
            
            // Apply text styling
            if (component.style) {
                element.style.fontSize = (component.style.fontSize || 16) + 'px';
                element.style.color = component.style.textColor || '#ffffff';
                element.style.fontWeight = component.style.fontWeight || 'normal';
                element.style.fontFamily = component.style.fontFamily || 'Arial, sans-serif';
                
                if (component.style.backgroundColor && component.style.backgroundColor !== 'transparent') {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity !== undefined) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Set text content
            element.textContent = component.data.text || 'Sample Text';
            
            container.appendChild(element);
        }

        // Helper function to scale text to maximally fit within container (grow and shrink)
        function scaleTextToFit(element, maxWidth, maxHeight) {
            if (!element || !element.textContent || maxWidth <= 0 || maxHeight <= 0) {
                return parseFloat(element?.style?.fontSize) || 16;
            }

            // Read current font size, with fallback
            const computed = window.getComputedStyle ? window.getComputedStyle(element) : null;
            const currentSize = parseFloat(element.style.fontSize || (computed && computed.fontSize)) || 16;
            let fontSize = currentSize;
            const minFontSize = 14; // keep readable
            const maxFontByHeight = Math.max(minFontSize, Math.floor(maxHeight)); // hard cap by box height

            // Prepare for measurement
            const originalVisibility = element.style.visibility;
            const originalPosition = element.style.position;
            const originalLeft = element.style.left;
            const originalTop = element.style.top;

            element.style.visibility = 'hidden';
            element.style.position = 'absolute';
            element.style.left = '-9999px';
            element.style.top = '-9999px';

            if (!element.parentNode) {
                document.body.appendChild(element);
            }

            const fits = () => {
                // Very small safety margins
                const containerWidth = maxWidth - 2;
                const containerHeight = maxHeight - 1;
                return element.scrollWidth <= containerWidth && element.scrollHeight <= containerHeight;
            };

            try {
                // Phase 1: If overflowing at current size, shrink until it fits or we hit min
                element.style.fontSize = fontSize + 'px';
                while (!fits() && fontSize > minFontSize) {
                    fontSize -= 1;
                    element.style.fontSize = fontSize + 'px';
                }

                // Phase 2: Try to grow to fill available space, bounded by height
                let lastGood = fontSize;
                while (fontSize < maxFontByHeight) {
                    fontSize += 1;
                    element.style.fontSize = fontSize + 'px';
                    if (fits()) {
                        lastGood = fontSize;
                        continue;
                    } else {
                        // Went too far, revert to last fitting size
                        fontSize = lastGood;
                        element.style.fontSize = fontSize + 'px';
                        break;
                    }
                }
            } catch (error) {
                console.error('Error scaling text:', error);
            } finally {
                // Restore styles
                element.style.visibility = originalVisibility;
                element.style.position = originalPosition;
                element.style.left = originalLeft;
                element.style.top = originalTop;

                if (element.parentNode === document.body && originalPosition !== 'absolute') {
                    document.body.removeChild(element);
                }
            }

            return fontSize;
        }

        function renderTennisComponent(component) {
            const container = document.getElementById('scoreboardContainer');
            
            const element = document.createElement('div');
            element.className = 'text-component tennis-component score-change-base';
            element.style.position = 'absolute';
            // Position component exactly as designed (no offset needed)
            element.style.left = component.position.x + 'px';
            element.style.top = component.position.y + 'px';
            element.style.width = component.size.width + 'px';
            element.style.height = component.size.height + 'px';
            element.style.zIndex = component.zIndex || 1000;
            
            // Apply flexbox layout (matching design canvas)
            element.style.display = 'flex';
            element.style.alignItems = 'center';
            element.style.paddingLeft = '8px';
            element.style.paddingRight = '8px';
            element.style.wordWrap = 'break-word';
            element.style.overflow = 'hidden';
            
            // Apply text alignment
            const textAlign = component.style ? component.style.textAlign || 'center' : 'center';
            switch (textAlign) {
                case 'left':
                    element.style.justifyContent = 'flex-start';
                    element.style.textAlign = 'left';
                    break;
                case 'right':
                    element.style.justifyContent = 'flex-end';
                    element.style.textAlign = 'right';
                    break;
                case 'center':
                default:
                    element.style.justifyContent = 'center';
                    element.style.textAlign = 'center';
                    break;
            }
            
            // Apply text styling with tennis-specific defaults
            if (component.style) {
                element.style.fontSize = (component.style.fontSize || 16) + 'px';
                element.style.color = component.style.textColor || '#ffffff';
                element.style.fontWeight = component.style.fontWeight || 'bold'; // Bold by default for tennis
                element.style.fontFamily = component.style.fontFamily || 'Arial, sans-serif';
                
                if (component.style.backgroundColor && component.style.backgroundColor !== 'transparent') {
                    element.style.backgroundColor = component.style.backgroundColor;
                }
                if (component.style.borderWidth) {
                    const borderColor = component.style.borderColor === 'transparent' ? 'transparent' : (component.style.borderColor || '#000');
                    element.style.border = `${component.style.borderWidth}px solid ${borderColor}`;
                }
                if (component.style.borderRadius) {
                    element.style.borderRadius = component.style.borderRadius + 'px';
                }
                if (component.style.opacity !== undefined) {
                    element.style.opacity = component.style.opacity;
                }
            }
            
            // Get fallback text based on component type
            let fallbackText = component.data.text || getDefaultTennisText(component.type, component.data.playerNumber);
            
            // For serve speed, show nothing until live data arrives
            if (component.type === 'tennis_serve_speed' && !component.data.text) {
                fallbackText = '';
            }
            
            // Set initial fallback text
            element.textContent = fallbackText;
            
            // Setup live data if this component has a binding
            setupLiveDataForComponent(element, component);
            
            // Add tennis component identifier for future live data updates
            element.setAttribute('data-component-id', component.id);
            element.setAttribute('data-component-type', component.type);
            element.setAttribute('data-player-number', component.data.playerNumber || 1);

            // Set data-set-number for tennis_detailed_set_score components
            if (component.type === 'tennis_detailed_set_score') {
                element.setAttribute('data-set-number', component.data.setNumber || 1);
            }

            // Set data-team-selection for tennis_team_names and tennis_adaptive_team_display components
            if (component.type === 'tennis_team_names' || component.type === 'tennis_adaptive_team_display') {
                element.setAttribute('data-team-selection', component.data.teamSelection || 0);
            }

            // Scale text to maximally fill the component bounds for player names and adaptive team display
            if ((component.type === 'tennis_player_name' && element.textContent && element.textContent !== 'Player 1' && element.textContent !== 'Player 2') ||
                (component.type === 'tennis_adaptive_team_display' && element.textContent && element.textContent !== 'School A - Smith vs School B - Johnson')) {
                const optimalFontSize = scaleTextToFit(element, component.size.width, component.size.height);
                element.style.fontSize = optimalFontSize + 'px';
            }

            container.appendChild(element);
        }

        function getDefaultTennisText(componentType, playerNumber) {
            switch (componentType) {
                case 'tennis_player_name':
                    return `Player ${playerNumber || 1}`;
                case 'tennis_game_score':
                    return '0';
                case 'tennis_set_score':
                    return '0';
                case 'tennis_match_score':
                    return '0';
                case 'tennis_serve_speed':
                    return ''; // Show nothing until data arrives
                case 'tennis_detailed_set_score':
                    return '0'; // Shows single set score for specific player and set
                case 'tennis_adaptive_team_display':
                    return 'School A - Smith vs School B - Johnson'; // Shows adaptive team display: school names for doubles, school names + last names for singles
                default:
                    return 'Tennis Data';
            }
        }

        function renderDefaultScoreboard(extraInfo = '') {
            const loadingMessage = document.getElementById('loadingMessage');
            
            loadingMessage.innerHTML = `
                <div style="text-align: center;">
                    <h1 style="font-size: 2rem; margin-bottom: 1rem;">Scoreboard Display</h1>
                    <p style="font-size: 1rem; color: #888;">No custom design loaded</p>
                    <p style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;">Create a design with image components to see it here</p>
                    ${extraInfo ? `<p style="font-size: 0.7rem; color: #555; margin-top: 1rem;">${extraInfo}</p>` : ''}
                </div>
            `;
        }

        function showMessage(message) {
            const loadingMessage = document.getElementById('loadingMessage');
            loadingMessage.innerHTML = `<div>${message}</div><div class="debug-info">${debugInfo ? debugInfo.textContent : ''}</div>`;
            loadingMessage.style.display = 'flex';
        }

        // Start initialization
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸš€ Scoreboard display window starting...');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ“‹ This window will show tennis match data in real-time');
            console.log('ðŸŽ¾ [SCOREBOARD] ðŸ” WebSocket connection handled by backend (Tauri)');
            updateDebug('DOM ready, starting...');
            initializeScoreboard();
        });

        // Also try on window load
        window.addEventListener('load', () => {
            if (initAttempts === 0) {
                console.log('ðŸŽ¾ [SCOREBOARD] ðŸ–¥ï¸ Scoreboard window fully loaded');
                updateDebug('Window loaded, starting...');
                initializeScoreboard();
            }
        });

        // Listen for messages from parent window (if any)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'scoreboardData') {
                console.log('Received scoreboard data via postMessage:', event.data.data);
                scoreboardData = event.data.data;
                renderScoreboard(scoreboardData);
            }
        });
    </script>
</body>
</html>